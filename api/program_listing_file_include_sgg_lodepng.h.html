<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Program Listing for File lodepng.h &mdash; Chess  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/collapsible-lists/css/tree_view.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
        <script src="../_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> Chess
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="library_root.html">Library API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Chess</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Program Listing for File lodepng.h</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/api/program_listing_file_include_sgg_lodepng.h.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="program-listing-for-file-lodepng-h">
<span id="program-listing-file-include-sgg-lodepng-h"></span><h1>Program Listing for File lodepng.h<a class="headerlink" href="#program-listing-for-file-lodepng-h" title="Permalink to this headline"></a></h1>
<p>↰ <a class="reference internal" href="file_include_sgg_lodepng.h.html#file-include-sgg-lodepng-h"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">include/sgg/lodepng.h</span></code>)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">LodePNG version 20200306</span>

<span class="cm">Copyright (c) 2005-2020 Lode Vandevenne</span>

<span class="cm">This software is provided &#39;as-is&#39;, without any express or implied</span>
<span class="cm">warranty. In no event will the authors be held liable for any damages</span>
<span class="cm">arising from the use of this software.</span>

<span class="cm">Permission is granted to anyone to use this software for any purpose,</span>
<span class="cm">including commercial applications, and to alter it and redistribute it</span>
<span class="cm">freely, subject to the following restrictions:</span>

<span class="cm">    1. The origin of this software must not be misrepresented; you must not</span>
<span class="cm">    claim that you wrote the original software. If you use this software</span>
<span class="cm">    in a product, an acknowledgment in the product documentation would be</span>
<span class="cm">    appreciated but is not required.</span>

<span class="cm">    2. Altered source versions must be plainly marked as such, and must not be</span>
<span class="cm">    misrepresented as being the original software.</span>

<span class="cm">    3. This notice may not be removed or altered from any source</span>
<span class="cm">    distribution.</span>
<span class="cm">*/</span><span class="w"></span>

<span class="cp">#ifndef LODEPNG_H</span>
<span class="cp">#define LODEPNG_H</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span><span class="c1"> /*for size_t*/</span><span class="cp"></span>

<span class="k">extern</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">LODEPNG_VERSION_STRING</span><span class="p">;</span><span class="w"></span>

<span class="cm">/*</span>
<span class="cm">The following #defines are used to create code sections. They can be disabled</span>
<span class="cm">to disable code sections, which can give faster compile time and smaller binary.</span>
<span class="cm">The &quot;NO_COMPILE&quot; defines are designed to be used to pass as defines to the</span>
<span class="cm">compiler command to disable them without modifying this header, e.g.</span>
<span class="cm">-DLODEPNG_NO_COMPILE_ZLIB for gcc.</span>
<span class="cm">In addition to those below, you can also define LODEPNG_NO_COMPILE_CRC to</span>
<span class="cm">allow implementing a custom lodepng_crc32.</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cm">/*deflate &amp; zlib. If disabled, you must specify alternative zlib functions in</span>
<span class="cm">the custom_zlib field of the compress and decompress settings*/</span><span class="w"></span>
<span class="cp">#ifndef LODEPNG_NO_COMPILE_ZLIB</span>
<span class="cp">#define LODEPNG_COMPILE_ZLIB</span>
<span class="cp">#endif</span>

<span class="cm">/*png encoder and png decoder*/</span><span class="w"></span>
<span class="cp">#ifndef LODEPNG_NO_COMPILE_PNG</span>
<span class="cp">#define LODEPNG_COMPILE_PNG</span>
<span class="cp">#endif</span>

<span class="cm">/*deflate&amp;zlib decoder and png decoder*/</span><span class="w"></span>
<span class="cp">#ifndef LODEPNG_NO_COMPILE_DECODER</span>
<span class="cp">#define LODEPNG_COMPILE_DECODER</span>
<span class="cp">#endif</span>

<span class="cm">/*deflate&amp;zlib encoder and png encoder*/</span><span class="w"></span>
<span class="cp">#ifndef LODEPNG_NO_COMPILE_ENCODER</span>
<span class="cp">#define LODEPNG_COMPILE_ENCODER</span>
<span class="cp">#endif</span>

<span class="cm">/*the optional built in harddisk file loading and saving functions*/</span><span class="w"></span>
<span class="cp">#ifndef LODEPNG_NO_COMPILE_DISK</span>
<span class="cp">#define LODEPNG_COMPILE_DISK</span>
<span class="cp">#endif</span>

<span class="cm">/*support for chunks other than IHDR, IDAT, PLTE, tRNS, IEND: ancillary and unknown chunks*/</span><span class="w"></span>
<span class="cp">#ifndef LODEPNG_NO_COMPILE_ANCILLARY_CHUNKS</span>
<span class="cp">#define LODEPNG_COMPILE_ANCILLARY_CHUNKS</span>
<span class="cp">#endif</span>

<span class="cm">/*ability to convert error numerical codes to English text string*/</span><span class="w"></span>
<span class="cp">#ifndef LODEPNG_NO_COMPILE_ERROR_TEXT</span>
<span class="cp">#define LODEPNG_COMPILE_ERROR_TEXT</span>
<span class="cp">#endif</span>

<span class="cm">/*Compile the default allocators (C&#39;s free, malloc and realloc). If you disable this,</span>
<span class="cm">you can define the functions lodepng_free, lodepng_malloc and lodepng_realloc in your</span>
<span class="cm">source files with custom allocators.*/</span><span class="w"></span>
<span class="cp">#ifndef LODEPNG_NO_COMPILE_ALLOCATORS</span>
<span class="cp">#define LODEPNG_COMPILE_ALLOCATORS</span>
<span class="cp">#endif</span>

<span class="cm">/*compile the C++ version (you can disable the C++ wrapper here even when compiling for C++)*/</span><span class="w"></span>
<span class="cp">#ifdef __cplusplus</span>
<span class="cp">#ifndef LODEPNG_NO_COMPILE_CPP</span>
<span class="cp">#define LODEPNG_COMPILE_CPP</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef LODEPNG_COMPILE_CPP</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/*LODEPNG_COMPILE_CPP*/</span><span class="cp"></span>

<span class="cp">#ifdef LODEPNG_COMPILE_PNG</span>
<span class="cm">/*The PNG color types (also used for raw image).*/</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">LodePNGColorType</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">LCT_GREY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="cm">/*grayscale: 1,2,4,8,16 bit*/</span><span class="w"></span>
<span class="w">  </span><span class="n">LCT_RGB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="cm">/*RGB: 8,16 bit*/</span><span class="w"></span>
<span class="w">  </span><span class="n">LCT_PALETTE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="cm">/*palette: 1,2,4,8 bit*/</span><span class="w"></span>
<span class="w">  </span><span class="n">LCT_GREY_ALPHA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="cm">/*grayscale with alpha: 8,16 bit*/</span><span class="w"></span>
<span class="w">  </span><span class="n">LCT_RGBA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="cm">/*RGB with alpha: 8,16 bit*/</span><span class="w"></span>
<span class="w">  </span><span class="cm">/*LCT_MAX_OCTET_VALUE lets the compiler allow this enum to represent any invalid</span>
<span class="cm">  byte value from 0 to 255 that could be present in an invalid PNG file header. Do</span>
<span class="cm">  not use, compare with or set the name LCT_MAX_OCTET_VALUE, instead either use</span>
<span class="cm">  the valid color type names above, or numeric values like 1 or 7 when checking for</span>
<span class="cm">  particular disallowed color type byte values, or cast to integer to print it.*/</span><span class="w"></span>
<span class="w">  </span><span class="n">LCT_MAX_OCTET_VALUE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">255</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">LodePNGColorType</span><span class="p">;</span><span class="w"></span>

<span class="cp">#ifdef LODEPNG_COMPILE_DECODER</span>
<span class="cm">/*</span>
<span class="cm">Converts PNG data in memory to raw pixel data.</span>
<span class="cm">out: Output parameter. Pointer to buffer that will contain the raw pixel data.</span>
<span class="cm">     After decoding, its size is w * h * (bytes per pixel) bytes larger than</span>
<span class="cm">     initially. Bytes per pixel depends on colortype and bitdepth.</span>
<span class="cm">     Must be freed after usage with free(*out).</span>
<span class="cm">     Note: for 16-bit per channel colors, uses big endian format like PNG does.</span>
<span class="cm">w: Output parameter. Pointer to width of pixel data.</span>
<span class="cm">h: Output parameter. Pointer to height of pixel data.</span>
<span class="cm">in: Memory buffer with the PNG file.</span>
<span class="cm">insize: size of the in buffer.</span>
<span class="cm">colortype: the desired color type for the raw output image. See explanation on PNG color types.</span>
<span class="cm">bitdepth: the desired bit depth for the raw output image. See explanation on PNG color types.</span>
<span class="cm">Return value: LodePNG error code (0 means no error).</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">lodepng_decode_memory</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="o">*</span><span class="w"> </span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="o">*</span><span class="w"> </span><span class="n">h</span><span class="p">,</span><span class="w"></span>
<span class="w">                               </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">insize</span><span class="p">,</span><span class="w"></span>
<span class="w">                               </span><span class="n">LodePNGColorType</span><span class="w"> </span><span class="n">colortype</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">bitdepth</span><span class="p">);</span><span class="w"></span>

<span class="cm">/*Same as lodepng_decode_memory, but always decodes to 32-bit RGBA raw image*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">lodepng_decode32</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="o">*</span><span class="w"> </span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="o">*</span><span class="w"> </span><span class="n">h</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">insize</span><span class="p">);</span><span class="w"></span>

<span class="cm">/*Same as lodepng_decode_memory, but always decodes to 24-bit RGB raw image*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">lodepng_decode24</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="o">*</span><span class="w"> </span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="o">*</span><span class="w"> </span><span class="n">h</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">insize</span><span class="p">);</span><span class="w"></span>

<span class="cp">#ifdef LODEPNG_COMPILE_DISK</span>
<span class="cm">/*</span>
<span class="cm">Load PNG from disk, from file with given name.</span>
<span class="cm">Same as the other decode functions, but instead takes a filename as input.</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">lodepng_decode_file</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="o">*</span><span class="w"> </span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="o">*</span><span class="w"> </span><span class="n">h</span><span class="p">,</span><span class="w"></span>
<span class="w">                             </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">,</span><span class="w"></span>
<span class="w">                             </span><span class="n">LodePNGColorType</span><span class="w"> </span><span class="n">colortype</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">bitdepth</span><span class="p">);</span><span class="w"></span>

<span class="cm">/*Same as lodepng_decode_file, but always decodes to 32-bit RGBA raw image.*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">lodepng_decode32_file</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="o">*</span><span class="w"> </span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="o">*</span><span class="w"> </span><span class="n">h</span><span class="p">,</span><span class="w"></span>
<span class="w">                               </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">);</span><span class="w"></span>

<span class="cm">/*Same as lodepng_decode_file, but always decodes to 24-bit RGB raw image.*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">lodepng_decode24_file</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="o">*</span><span class="w"> </span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="o">*</span><span class="w"> </span><span class="n">h</span><span class="p">,</span><span class="w"></span>
<span class="w">                               </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif </span><span class="cm">/*LODEPNG_COMPILE_DISK*/</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/*LODEPNG_COMPILE_DECODER*/</span><span class="cp"></span>


<span class="cp">#ifdef LODEPNG_COMPILE_ENCODER</span>
<span class="cm">/*</span>
<span class="cm">Converts raw pixel data into a PNG image in memory. The colortype and bitdepth</span>
<span class="cm">  of the output PNG image cannot be chosen, they are automatically determined</span>
<span class="cm">  by the colortype, bitdepth and content of the input pixel data.</span>
<span class="cm">  Note: for 16-bit per channel colors, needs big endian format like PNG does.</span>
<span class="cm">out: Output parameter. Pointer to buffer that will contain the PNG image data.</span>
<span class="cm">     Must be freed after usage with free(*out).</span>
<span class="cm">outsize: Output parameter. Pointer to the size in bytes of the out buffer.</span>
<span class="cm">image: The raw pixel data to encode. The size of this buffer should be</span>
<span class="cm">       w * h * (bytes per pixel), bytes per pixel depends on colortype and bitdepth.</span>
<span class="cm">w: width of the raw pixel data in pixels.</span>
<span class="cm">h: height of the raw pixel data in pixels.</span>
<span class="cm">colortype: the color type of the raw input image. See explanation on PNG color types.</span>
<span class="cm">bitdepth: the bit depth of the raw input image. See explanation on PNG color types.</span>
<span class="cm">Return value: LodePNG error code (0 means no error).</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">lodepng_encode_memory</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="o">*</span><span class="w"> </span><span class="n">outsize</span><span class="p">,</span><span class="w"></span>
<span class="w">                               </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">image</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">h</span><span class="p">,</span><span class="w"></span>
<span class="w">                               </span><span class="n">LodePNGColorType</span><span class="w"> </span><span class="n">colortype</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">bitdepth</span><span class="p">);</span><span class="w"></span>

<span class="cm">/*Same as lodepng_encode_memory, but always encodes from 32-bit RGBA raw image.*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">lodepng_encode32</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="o">*</span><span class="w"> </span><span class="n">outsize</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">image</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">h</span><span class="p">);</span><span class="w"></span>

<span class="cm">/*Same as lodepng_encode_memory, but always encodes from 24-bit RGB raw image.*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">lodepng_encode24</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="o">*</span><span class="w"> </span><span class="n">outsize</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">image</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">h</span><span class="p">);</span><span class="w"></span>

<span class="cp">#ifdef LODEPNG_COMPILE_DISK</span>
<span class="cm">/*</span>
<span class="cm">Converts raw pixel data into a PNG file on disk.</span>
<span class="cm">Same as the other encode functions, but instead takes a filename as output.</span>
<span class="cm">NOTE: This overwrites existing files without warning!</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">lodepng_encode_file</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">,</span><span class="w"></span>
<span class="w">                             </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">image</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">h</span><span class="p">,</span><span class="w"></span>
<span class="w">                             </span><span class="n">LodePNGColorType</span><span class="w"> </span><span class="n">colortype</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">bitdepth</span><span class="p">);</span><span class="w"></span>

<span class="cm">/*Same as lodepng_encode_file, but always encodes from 32-bit RGBA raw image.*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">lodepng_encode32_file</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">,</span><span class="w"></span>
<span class="w">                               </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">image</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">h</span><span class="p">);</span><span class="w"></span>

<span class="cm">/*Same as lodepng_encode_file, but always encodes from 24-bit RGB raw image.*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">lodepng_encode24_file</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">,</span><span class="w"></span>
<span class="w">                               </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">image</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">h</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif </span><span class="cm">/*LODEPNG_COMPILE_DISK*/</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/*LODEPNG_COMPILE_ENCODER*/</span><span class="cp"></span>


<span class="cp">#ifdef LODEPNG_COMPILE_CPP</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">lodepng</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="cp">#ifdef LODEPNG_COMPILE_DECODER</span>
<span class="cm">/*Same as lodepng_decode_memory, but decodes to an std::vector. The colortype</span>
<span class="cm">is the format to output the pixels to. Default is RGBA 8-bit per channel.*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">decode</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="o">&amp;</span><span class="w"> </span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="o">&amp;</span><span class="w"> </span><span class="n">h</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">insize</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">LodePNGColorType</span><span class="w"> </span><span class="n">colortype</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LCT_RGBA</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">bitdepth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">decode</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="o">&amp;</span><span class="w"> </span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="o">&amp;</span><span class="w"> </span><span class="n">h</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">LodePNGColorType</span><span class="w"> </span><span class="n">colortype</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LCT_RGBA</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">bitdepth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w"></span>
<span class="cp">#ifdef LODEPNG_COMPILE_DISK</span>
<span class="cm">/*</span>
<span class="cm">Converts PNG file from disk to raw pixel data in memory.</span>
<span class="cm">Same as the other decode functions, but instead takes a filename as input.</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">decode</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="o">&amp;</span><span class="w"> </span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="o">&amp;</span><span class="w"> </span><span class="n">h</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">filename</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">LodePNGColorType</span><span class="w"> </span><span class="n">colortype</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LCT_RGBA</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">bitdepth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif </span><span class="cm">/* LODEPNG_COMPILE_DISK */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* LODEPNG_COMPILE_DECODER */</span><span class="cp"></span>

<span class="cp">#ifdef LODEPNG_COMPILE_ENCODER</span>
<span class="cm">/*Same as lodepng_encode_memory, but encodes to an std::vector. colortype</span>
<span class="cm">is that of the raw input data. The output PNG color type will be auto chosen.*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">encode</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">h</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">LodePNGColorType</span><span class="w"> </span><span class="n">colortype</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LCT_RGBA</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">bitdepth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">encode</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">h</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">LodePNGColorType</span><span class="w"> </span><span class="n">colortype</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LCT_RGBA</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">bitdepth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w"></span>
<span class="cp">#ifdef LODEPNG_COMPILE_DISK</span>
<span class="cm">/*</span>
<span class="cm">Converts 32-bit RGBA raw pixel data into a PNG file on disk.</span>
<span class="cm">Same as the other encode functions, but instead takes a filename as output.</span>
<span class="cm">NOTE: This overwrites existing files without warning!</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">encode</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">filename</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">h</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">LodePNGColorType</span><span class="w"> </span><span class="n">colortype</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LCT_RGBA</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">bitdepth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">encode</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">filename</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">h</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">LodePNGColorType</span><span class="w"> </span><span class="n">colortype</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LCT_RGBA</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">bitdepth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif </span><span class="cm">/* LODEPNG_COMPILE_DISK */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* LODEPNG_COMPILE_ENCODER */</span><span class="cp"></span>
<span class="p">}</span><span class="w"> </span><span class="cm">/* namespace lodepng */</span><span class="w"></span>
<span class="cp">#endif </span><span class="cm">/*LODEPNG_COMPILE_CPP*/</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/*LODEPNG_COMPILE_PNG*/</span><span class="cp"></span>

<span class="cp">#ifdef LODEPNG_COMPILE_ERROR_TEXT</span>
<span class="cm">/*Returns an English description of the numerical error code.*/</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">lodepng_error_text</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">code</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif </span><span class="cm">/*LODEPNG_COMPILE_ERROR_TEXT*/</span><span class="cp"></span>

<span class="cp">#ifdef LODEPNG_COMPILE_DECODER</span>
<span class="cm">/*Settings for zlib decompression*/</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">LodePNGDecompressSettings</span><span class="w"> </span><span class="n">LodePNGDecompressSettings</span><span class="p">;</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">LodePNGDecompressSettings</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="cm">/* Check LodePNGDecoderSettings for more ignorable errors such as ignore_crc */</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">ignore_adler32</span><span class="p">;</span><span class="w"> </span><span class="cm">/*if 1, continue and don&#39;t give an error message if the Adler32 checksum is corrupted*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">ignore_nlen</span><span class="p">;</span><span class="w"> </span><span class="cm">/*ignore complement of len checksum in uncompressed blocks*/</span><span class="w"></span>

<span class="w">  </span><span class="cm">/*use custom zlib decoder instead of built in one (default: null)*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">custom_zlib</span><span class="p">)(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="o">*</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="k">const</span><span class="w"> </span><span class="n">LodePNGDecompressSettings</span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="cm">/*use custom deflate decoder instead of built in one (default: null)</span>
<span class="cm">  if custom_zlib is not null, custom_inflate is ignored (the zlib format uses deflate)*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">custom_inflate</span><span class="p">)(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="o">*</span><span class="p">,</span><span class="w"></span>
<span class="w">                             </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="p">,</span><span class="w"></span>
<span class="w">                             </span><span class="k">const</span><span class="w"> </span><span class="n">LodePNGDecompressSettings</span><span class="o">*</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">custom_context</span><span class="p">;</span><span class="w"> </span><span class="cm">/*optional custom settings for custom functions*/</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">extern</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">LodePNGDecompressSettings</span><span class="w"> </span><span class="n">lodepng_default_decompress_settings</span><span class="p">;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">lodepng_decompress_settings_init</span><span class="p">(</span><span class="n">LodePNGDecompressSettings</span><span class="o">*</span><span class="w"> </span><span class="n">settings</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif </span><span class="cm">/*LODEPNG_COMPILE_DECODER*/</span><span class="cp"></span>

<span class="cp">#ifdef LODEPNG_COMPILE_ENCODER</span>
<span class="cm">/*</span>
<span class="cm">Settings for zlib compression. Tweaking these settings tweaks the balance</span>
<span class="cm">between speed and compression ratio.</span>
<span class="cm">*/</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">LodePNGCompressSettings</span><span class="w"> </span><span class="n">LodePNGCompressSettings</span><span class="p">;</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">LodePNGCompressSettings</span><span class="w"> </span><span class="cm">/*deflate = compress*/</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="cm">/*LZ77 related settings*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">btype</span><span class="p">;</span><span class="w"> </span><span class="cm">/*the block type for LZ (0, 1, 2 or 3, see zlib standard). Should be 2 for proper compression.*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">use_lz77</span><span class="p">;</span><span class="w"> </span><span class="cm">/*whether or not to use LZ77. Should be 1 for proper compression.*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">windowsize</span><span class="p">;</span><span class="w"> </span><span class="cm">/*must be a power of two &lt;= 32768. higher compresses more but is slower. Default value: 2048.*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">minmatch</span><span class="p">;</span><span class="w"> </span><span class="cm">/*minimum lz77 length. 3 is normally best, 6 can be better for some PNGs. Default: 0*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">nicematch</span><span class="p">;</span><span class="w"> </span><span class="cm">/*stop searching if &gt;= this length found. Set to 258 for best compression. Default: 128*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">lazymatching</span><span class="p">;</span><span class="w"> </span><span class="cm">/*use lazy matching: better compression but a bit slower. Default: true*/</span><span class="w"></span>

<span class="w">  </span><span class="cm">/*use custom zlib encoder instead of built in one (default: null)*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">custom_zlib</span><span class="p">)(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="o">*</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="k">const</span><span class="w"> </span><span class="n">LodePNGCompressSettings</span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="cm">/*use custom deflate encoder instead of built in one (default: null)</span>
<span class="cm">  if custom_zlib is used, custom_deflate is ignored since only the built in</span>
<span class="cm">  zlib function will call custom_deflate*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">custom_deflate</span><span class="p">)(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="o">*</span><span class="p">,</span><span class="w"></span>
<span class="w">                             </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="p">,</span><span class="w"></span>
<span class="w">                             </span><span class="k">const</span><span class="w"> </span><span class="n">LodePNGCompressSettings</span><span class="o">*</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">custom_context</span><span class="p">;</span><span class="w"> </span><span class="cm">/*optional custom settings for custom functions*/</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">extern</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">LodePNGCompressSettings</span><span class="w"> </span><span class="n">lodepng_default_compress_settings</span><span class="p">;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">lodepng_compress_settings_init</span><span class="p">(</span><span class="n">LodePNGCompressSettings</span><span class="o">*</span><span class="w"> </span><span class="n">settings</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif </span><span class="cm">/*LODEPNG_COMPILE_ENCODER*/</span><span class="cp"></span>

<span class="cp">#ifdef LODEPNG_COMPILE_PNG</span>
<span class="cm">/*</span>
<span class="cm">Color mode of an image. Contains all information required to decode the pixel</span>
<span class="cm">bits to RGBA colors. This information is the same as used in the PNG file</span>
<span class="cm">format, and is used both for PNG and raw image data in LodePNG.</span>
<span class="cm">*/</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">LodePNGColorMode</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="cm">/*header (IHDR)*/</span><span class="w"></span>
<span class="w">  </span><span class="n">LodePNGColorType</span><span class="w"> </span><span class="n">colortype</span><span class="p">;</span><span class="w"> </span><span class="cm">/*color type, see PNG standard or documentation further in this header file*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">bitdepth</span><span class="p">;</span><span class="w">  </span><span class="cm">/*bits per sample, see PNG standard or documentation further in this header file*/</span><span class="w"></span>

<span class="w">  </span><span class="cm">/*</span>
<span class="cm">  palette (PLTE and tRNS)</span>

<span class="cm">  Dynamically allocated with the colors of the palette, including alpha.</span>
<span class="cm">  This field may not be allocated directly, use lodepng_color_mode_init first,</span>
<span class="cm">  then lodepng_palette_add per color to correctly initialize it (to ensure size</span>
<span class="cm">  of exactly 1024 bytes).</span>

<span class="cm">  The alpha channels must be set as well, set them to 255 for opaque images.</span>

<span class="cm">  When decoding, by default you can ignore this palette, since LodePNG already</span>
<span class="cm">  fills the palette colors in the pixels of the raw RGBA output.</span>

<span class="cm">  The palette is only supported for color type 3.</span>
<span class="cm">  */</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">palette</span><span class="p">;</span><span class="w"> </span><span class="cm">/*palette in RGBARGBA... order. Must be either 0, or when allocated must have 1024 bytes*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">palettesize</span><span class="p">;</span><span class="w"> </span><span class="cm">/*palette size in number of colors (amount of used bytes is 4 * palettesize)*/</span><span class="w"></span>

<span class="w">  </span><span class="cm">/*</span>
<span class="cm">  transparent color key (tRNS)</span>

<span class="cm">  This color uses the same bit depth as the bitdepth value in this struct, which can be 1-bit to 16-bit.</span>
<span class="cm">  For grayscale PNGs, r, g and b will all 3 be set to the same.</span>

<span class="cm">  When decoding, by default you can ignore this information, since LodePNG sets</span>
<span class="cm">  pixels with this key to transparent already in the raw RGBA output.</span>

<span class="cm">  The color key is only supported for color types 0 and 2.</span>
<span class="cm">  */</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">key_defined</span><span class="p">;</span><span class="w"> </span><span class="cm">/*is a transparent color key given? 0 = false, 1 = true*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">key_r</span><span class="p">;</span><span class="w">       </span><span class="cm">/*red/grayscale component of color key*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">key_g</span><span class="p">;</span><span class="w">       </span><span class="cm">/*green component of color key*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">key_b</span><span class="p">;</span><span class="w">       </span><span class="cm">/*blue component of color key*/</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">LodePNGColorMode</span><span class="p">;</span><span class="w"></span>

<span class="cm">/*init, cleanup and copy functions to use with this struct*/</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">lodepng_color_mode_init</span><span class="p">(</span><span class="n">LodePNGColorMode</span><span class="o">*</span><span class="w"> </span><span class="n">info</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">lodepng_color_mode_cleanup</span><span class="p">(</span><span class="n">LodePNGColorMode</span><span class="o">*</span><span class="w"> </span><span class="n">info</span><span class="p">);</span><span class="w"></span>
<span class="cm">/*return value is error code (0 means no error)*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">lodepng_color_mode_copy</span><span class="p">(</span><span class="n">LodePNGColorMode</span><span class="o">*</span><span class="w"> </span><span class="n">dest</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">LodePNGColorMode</span><span class="o">*</span><span class="w"> </span><span class="n">source</span><span class="p">);</span><span class="w"></span>
<span class="cm">/* Makes a temporary LodePNGColorMode that does not need cleanup (no palette) */</span><span class="w"></span>
<span class="n">LodePNGColorMode</span><span class="w"> </span><span class="nf">lodepng_color_mode_make</span><span class="p">(</span><span class="n">LodePNGColorType</span><span class="w"> </span><span class="n">colortype</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">bitdepth</span><span class="p">);</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">lodepng_palette_clear</span><span class="p">(</span><span class="n">LodePNGColorMode</span><span class="o">*</span><span class="w"> </span><span class="n">info</span><span class="p">);</span><span class="w"></span>
<span class="cm">/*add 1 color to the palette*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">lodepng_palette_add</span><span class="p">(</span><span class="n">LodePNGColorMode</span><span class="o">*</span><span class="w"> </span><span class="n">info</span><span class="p">,</span><span class="w"></span>
<span class="w">                             </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">a</span><span class="p">);</span><span class="w"></span>

<span class="cm">/*get the total amount of bits per pixel, based on colortype and bitdepth in the struct*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">lodepng_get_bpp</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">LodePNGColorMode</span><span class="o">*</span><span class="w"> </span><span class="n">info</span><span class="p">);</span><span class="w"></span>
<span class="cm">/*get the amount of color channels used, based on colortype in the struct.</span>
<span class="cm">If a palette is used, it counts as 1 channel.*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">lodepng_get_channels</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">LodePNGColorMode</span><span class="o">*</span><span class="w"> </span><span class="n">info</span><span class="p">);</span><span class="w"></span>
<span class="cm">/*is it a grayscale type? (only colortype 0 or 4)*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">lodepng_is_greyscale_type</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">LodePNGColorMode</span><span class="o">*</span><span class="w"> </span><span class="n">info</span><span class="p">);</span><span class="w"></span>
<span class="cm">/*has it got an alpha channel? (only colortype 2 or 6)*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">lodepng_is_alpha_type</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">LodePNGColorMode</span><span class="o">*</span><span class="w"> </span><span class="n">info</span><span class="p">);</span><span class="w"></span>
<span class="cm">/*has it got a palette? (only colortype 3)*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">lodepng_is_palette_type</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">LodePNGColorMode</span><span class="o">*</span><span class="w"> </span><span class="n">info</span><span class="p">);</span><span class="w"></span>
<span class="cm">/*only returns true if there is a palette and there is a value in the palette with alpha &lt; 255.</span>
<span class="cm">Loops through the palette to check this.*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">lodepng_has_palette_alpha</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">LodePNGColorMode</span><span class="o">*</span><span class="w"> </span><span class="n">info</span><span class="p">);</span><span class="w"></span>
<span class="cm">/*</span>
<span class="cm">Check if the given color info indicates the possibility of having non-opaque pixels in the PNG image.</span>
<span class="cm">Returns true if the image can have translucent or invisible pixels (it still be opaque if it doesn&#39;t use such pixels).</span>
<span class="cm">Returns false if the image can only have opaque pixels.</span>
<span class="cm">In detail, it returns true only if it&#39;s a color type with alpha, or has a palette with non-opaque values,</span>
<span class="cm">or if &quot;key_defined&quot; is true.</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">lodepng_can_have_alpha</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">LodePNGColorMode</span><span class="o">*</span><span class="w"> </span><span class="n">info</span><span class="p">);</span><span class="w"></span>
<span class="cm">/*Returns the byte size of a raw image buffer with given width, height and color mode*/</span><span class="w"></span>
<span class="kt">size_t</span><span class="w"> </span><span class="nf">lodepng_get_raw_size</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">h</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">LodePNGColorMode</span><span class="o">*</span><span class="w"> </span><span class="n">color</span><span class="p">);</span><span class="w"></span>

<span class="cp">#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS</span>
<span class="cm">/*The information of a Time chunk in PNG.*/</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">LodePNGTime</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">year</span><span class="p">;</span><span class="w">    </span><span class="cm">/*2 bytes used (0-65535)*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">month</span><span class="p">;</span><span class="w">   </span><span class="cm">/*1-12*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">day</span><span class="p">;</span><span class="w">     </span><span class="cm">/*1-31*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">hour</span><span class="p">;</span><span class="w">    </span><span class="cm">/*0-23*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">minute</span><span class="p">;</span><span class="w">  </span><span class="cm">/*0-59*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">second</span><span class="p">;</span><span class="w">  </span><span class="cm">/*0-60 (to allow for leap seconds)*/</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">LodePNGTime</span><span class="p">;</span><span class="w"></span>
<span class="cp">#endif </span><span class="cm">/*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/</span><span class="cp"></span>

<span class="cm">/*Information about the PNG image, except pixels, width and height.*/</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">LodePNGInfo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="cm">/*header (IHDR), palette (PLTE) and transparency (tRNS) chunks*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">compression_method</span><span class="p">;</span><span class="cm">/*compression method of the original file. Always 0.*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">filter_method</span><span class="p">;</span><span class="w">     </span><span class="cm">/*filter method of the original file*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">interlace_method</span><span class="p">;</span><span class="w">  </span><span class="cm">/*interlace method of the original file: 0=none, 1=Adam7*/</span><span class="w"></span>
<span class="w">  </span><span class="n">LodePNGColorMode</span><span class="w"> </span><span class="n">color</span><span class="p">;</span><span class="w">     </span><span class="cm">/*color type and bits, palette and transparency of the PNG file*/</span><span class="w"></span>

<span class="cp">#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS</span>
<span class="w">  </span><span class="cm">/*</span>
<span class="cm">  Suggested background color chunk (bKGD)</span>

<span class="cm">  This uses the same color mode and bit depth as the PNG (except no alpha channel),</span>
<span class="cm">  with values truncated to the bit depth in the unsigned integer.</span>

<span class="cm">  For grayscale and palette PNGs, the value is stored in background_r. The values</span>
<span class="cm">  in background_g and background_b are then unused.</span>

<span class="cm">  So when decoding, you may get these in a different color mode than the one you requested</span>
<span class="cm">  for the raw pixels.</span>

<span class="cm">  When encoding with auto_convert, you must use the color model defined in info_png.color for</span>
<span class="cm">  these values. The encoder normally ignores info_png.color when auto_convert is on, but will</span>
<span class="cm">  use it to interpret these values (and convert copies of them to its chosen color model).</span>

<span class="cm">  When encoding, avoid setting this to an expensive color, such as a non-gray value</span>
<span class="cm">  when the image is gray, or the compression will be worse since it will be forced to</span>
<span class="cm">  write the PNG with a more expensive color mode (when auto_convert is on).</span>

<span class="cm">  The decoder does not use this background color to edit the color of pixels. This is a</span>
<span class="cm">  completely optional metadata feature.</span>
<span class="cm">  */</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">background_defined</span><span class="p">;</span><span class="w"> </span><span class="cm">/*is a suggested background color given?*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">background_r</span><span class="p">;</span><span class="w">       </span><span class="cm">/*red/gray/palette component of suggested background color*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">background_g</span><span class="p">;</span><span class="w">       </span><span class="cm">/*green component of suggested background color*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">background_b</span><span class="p">;</span><span class="w">       </span><span class="cm">/*blue component of suggested background color*/</span><span class="w"></span>

<span class="w">  </span><span class="cm">/*</span>
<span class="cm">  non-international text chunks (tEXt and zTXt)</span>

<span class="cm">  The char** arrays each contain num strings. The actual messages are in</span>
<span class="cm">  text_strings, while text_keys are keywords that give a short description what</span>
<span class="cm">  the actual text represents, e.g. Title, Author, Description, or anything else.</span>

<span class="cm">  All the string fields below including keys, names and language tags are null terminated.</span>
<span class="cm">  The PNG specification uses null characters for the keys, names and tags, and forbids null</span>
<span class="cm">  characters to appear in the main text which is why we can use null termination everywhere here.</span>

<span class="cm">  A keyword is minimum 1 character and maximum 79 characters long. It&#39;s</span>
<span class="cm">  discouraged to use a single line length longer than 79 characters for texts.</span>

<span class="cm">  Don&#39;t allocate these text buffers yourself. Use the init/cleanup functions</span>
<span class="cm">  correctly and use lodepng_add_text and lodepng_clear_text.</span>
<span class="cm">  */</span><span class="w"></span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">text_num</span><span class="p">;</span><span class="w"> </span><span class="cm">/*the amount of texts in these char** buffers (there may be more texts in itext)*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">text_keys</span><span class="p">;</span><span class="w"> </span><span class="cm">/*the keyword of a text chunk (e.g. &quot;Comment&quot;)*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">text_strings</span><span class="p">;</span><span class="w"> </span><span class="cm">/*the actual text*/</span><span class="w"></span>

<span class="w">  </span><span class="cm">/*</span>
<span class="cm">  international text chunks (iTXt)</span>
<span class="cm">  Similar to the non-international text chunks, but with additional strings</span>
<span class="cm">  &quot;langtags&quot; and &quot;transkeys&quot;.</span>
<span class="cm">  */</span><span class="w"></span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">itext_num</span><span class="p">;</span><span class="w"> </span><span class="cm">/*the amount of international texts in this PNG*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">itext_keys</span><span class="p">;</span><span class="w"> </span><span class="cm">/*the English keyword of the text chunk (e.g. &quot;Comment&quot;)*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">itext_langtags</span><span class="p">;</span><span class="w"> </span><span class="cm">/*language tag for this text&#39;s language, ISO/IEC 646 string, e.g. ISO 639 language tag*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">itext_transkeys</span><span class="p">;</span><span class="w"> </span><span class="cm">/*keyword translated to the international language - UTF-8 string*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">itext_strings</span><span class="p">;</span><span class="w"> </span><span class="cm">/*the actual international text - UTF-8 string*/</span><span class="w"></span>

<span class="w">  </span><span class="cm">/*time chunk (tIME)*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">time_defined</span><span class="p">;</span><span class="w"> </span><span class="cm">/*set to 1 to make the encoder generate a tIME chunk*/</span><span class="w"></span>
<span class="w">  </span><span class="n">LodePNGTime</span><span class="w"> </span><span class="n">time</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="cm">/*phys chunk (pHYs)*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">phys_defined</span><span class="p">;</span><span class="w"> </span><span class="cm">/*if 0, there is no pHYs chunk and the values below are undefined, if 1 else there is one*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">phys_x</span><span class="p">;</span><span class="w"> </span><span class="cm">/*pixels per unit in x direction*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">phys_y</span><span class="p">;</span><span class="w"> </span><span class="cm">/*pixels per unit in y direction*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">phys_unit</span><span class="p">;</span><span class="w"> </span><span class="cm">/*may be 0 (unknown unit) or 1 (metre)*/</span><span class="w"></span>

<span class="w">  </span><span class="cm">/*</span>
<span class="cm">  Color profile related chunks: gAMA, cHRM, sRGB, iCPP</span>

<span class="cm">  LodePNG does not apply any color conversions on pixels in the encoder or decoder and does not interpret these color</span>
<span class="cm">  profile values. It merely passes on the information. If you wish to use color profiles and convert colors, please</span>
<span class="cm">  use these values with a color management library.</span>

<span class="cm">  See the PNG, ICC and sRGB specifications for more information about the meaning of these values.</span>
<span class="cm">  */</span><span class="w"></span>

<span class="w">  </span><span class="cm">/* gAMA chunk: optional, overridden by sRGB or iCCP if those are present. */</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">gama_defined</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Whether a gAMA chunk is present (0 = not present, 1 = present). */</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">gama_gamma</span><span class="p">;</span><span class="w">   </span><span class="cm">/* Gamma exponent times 100000 */</span><span class="w"></span>

<span class="w">  </span><span class="cm">/* cHRM chunk: optional, overridden by sRGB or iCCP if those are present. */</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">chrm_defined</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Whether a cHRM chunk is present (0 = not present, 1 = present). */</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">chrm_white_x</span><span class="p">;</span><span class="w"> </span><span class="cm">/* White Point x times 100000 */</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">chrm_white_y</span><span class="p">;</span><span class="w"> </span><span class="cm">/* White Point y times 100000 */</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">chrm_red_x</span><span class="p">;</span><span class="w">   </span><span class="cm">/* Red x times 100000 */</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">chrm_red_y</span><span class="p">;</span><span class="w">   </span><span class="cm">/* Red y times 100000 */</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">chrm_green_x</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Green x times 100000 */</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">chrm_green_y</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Green y times 100000 */</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">chrm_blue_x</span><span class="p">;</span><span class="w">  </span><span class="cm">/* Blue x times 100000 */</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">chrm_blue_y</span><span class="p">;</span><span class="w">  </span><span class="cm">/* Blue y times 100000 */</span><span class="w"></span>

<span class="w">  </span><span class="cm">/*</span>
<span class="cm">  sRGB chunk: optional. May not appear at the same time as iCCP.</span>
<span class="cm">  If gAMA is also present gAMA must contain value 45455.</span>
<span class="cm">  If cHRM is also present cHRM must contain respectively 31270,32900,64000,33000,30000,60000,15000,6000.</span>
<span class="cm">  */</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">srgb_defined</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Whether an sRGB chunk is present (0 = not present, 1 = present). */</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">srgb_intent</span><span class="p">;</span><span class="w">  </span><span class="cm">/* Rendering intent: 0=perceptual, 1=rel. colorimetric, 2=saturation, 3=abs. colorimetric */</span><span class="w"></span>

<span class="w">  </span><span class="cm">/*</span>
<span class="cm">  iCCP chunk: optional. May not appear at the same time as sRGB.</span>

<span class="cm">  LodePNG does not parse or use the ICC profile (except its color space header field for an edge case), a</span>
<span class="cm">  separate library to handle the ICC data (not included in LodePNG) format is needed to use it for color</span>
<span class="cm">  management and conversions.</span>

<span class="cm">  For encoding, if iCCP is present, gAMA and cHRM are recommended to be added as well with values that match the ICC</span>
<span class="cm">  profile as closely as possible, if you wish to do this you should provide the correct values for gAMA and cHRM and</span>
<span class="cm">  enable their &#39;_defined&#39; flags since LodePNG will not automatically compute them from the ICC profile.</span>

<span class="cm">  For encoding, the ICC profile is required by the PNG specification to be an &quot;RGB&quot; profile for non-gray</span>
<span class="cm">  PNG color types and a &quot;GRAY&quot; profile for gray PNG color types. If you disable auto_convert, you must ensure</span>
<span class="cm">  the ICC profile type matches your requested color type, else the encoder gives an error. If auto_convert is</span>
<span class="cm">  enabled (the default), and the ICC profile is not a good match for the pixel data, this will result in an encoder</span>
<span class="cm">  error if the pixel data has non-gray pixels for a GRAY profile, or a silent less-optimal compression of the pixel</span>
<span class="cm">  data if the pixels could be encoded as grayscale but the ICC profile is RGB.</span>

<span class="cm">  To avoid this do not set an ICC profile in the image unless there is a good reason for it, and when doing so</span>
<span class="cm">  make sure you compute it carefully to avoid the above problems.</span>
<span class="cm">  */</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">iccp_defined</span><span class="p">;</span><span class="w">      </span><span class="cm">/* Whether an iCCP chunk is present (0 = not present, 1 = present). */</span><span class="w"></span>
<span class="w">  </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">iccp_name</span><span class="p">;</span><span class="w">            </span><span class="cm">/* Null terminated string with profile name, 1-79 bytes */</span><span class="w"></span>
<span class="w">  </span><span class="cm">/*</span>
<span class="cm">  The ICC profile in iccp_profile_size bytes.</span>
<span class="cm">  Don&#39;t allocate this buffer yourself. Use the init/cleanup functions</span>
<span class="cm">  correctly and use lodepng_set_icc and lodepng_clear_icc.</span>
<span class="cm">  */</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">iccp_profile</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">iccp_profile_size</span><span class="p">;</span><span class="w"> </span><span class="cm">/* The size of iccp_profile in bytes */</span><span class="w"></span>

<span class="w">  </span><span class="cm">/* End of color profile related chunks */</span><span class="w"></span>


<span class="w">  </span><span class="cm">/*</span>
<span class="cm">  unknown chunks: chunks not known by LodePNG, passed on byte for byte.</span>

<span class="cm">  There are 3 buffers, one for each position in the PNG where unknown chunks can appear.</span>
<span class="cm">  Each buffer contains all unknown chunks for that position consecutively.</span>
<span class="cm">  The 3 positions are:</span>
<span class="cm">  0: between IHDR and PLTE, 1: between PLTE and IDAT, 2: between IDAT and IEND.</span>

<span class="cm">  For encoding, do not store critical chunks or known chunks that are enabled with a &quot;_defined&quot; flag</span>
<span class="cm">  above in here, since the encoder will blindly follow this and could then encode an invalid PNG file</span>
<span class="cm">  (such as one with two IHDR chunks or the disallowed combination of sRGB with iCCP). But do use</span>
<span class="cm">  this if you wish to store an ancillary chunk that is not supported by LodePNG (such as sPLT or hIST),</span>
<span class="cm">  or any non-standard PNG chunk.</span>

<span class="cm">  Do not allocate or traverse this data yourself. Use the chunk traversing functions declared</span>
<span class="cm">  later, such as lodepng_chunk_next and lodepng_chunk_append, to read/write this struct.</span>
<span class="cm">  */</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">unknown_chunks_data</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">unknown_chunks_size</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span><span class="w"> </span><span class="cm">/*size in bytes of the unknown chunks, given for protection*/</span><span class="w"></span>
<span class="cp">#endif </span><span class="cm">/*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/</span><span class="cp"></span>
<span class="p">}</span><span class="w"> </span><span class="n">LodePNGInfo</span><span class="p">;</span><span class="w"></span>

<span class="cm">/*init, cleanup and copy functions to use with this struct*/</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">lodepng_info_init</span><span class="p">(</span><span class="n">LodePNGInfo</span><span class="o">*</span><span class="w"> </span><span class="n">info</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">lodepng_info_cleanup</span><span class="p">(</span><span class="n">LodePNGInfo</span><span class="o">*</span><span class="w"> </span><span class="n">info</span><span class="p">);</span><span class="w"></span>
<span class="cm">/*return value is error code (0 means no error)*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">lodepng_info_copy</span><span class="p">(</span><span class="n">LodePNGInfo</span><span class="o">*</span><span class="w"> </span><span class="n">dest</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">LodePNGInfo</span><span class="o">*</span><span class="w"> </span><span class="n">source</span><span class="p">);</span><span class="w"></span>

<span class="cp">#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">lodepng_add_text</span><span class="p">(</span><span class="n">LodePNGInfo</span><span class="o">*</span><span class="w"> </span><span class="n">info</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">str</span><span class="p">);</span><span class="w"> </span><span class="cm">/*push back both texts at once*/</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">lodepng_clear_text</span><span class="p">(</span><span class="n">LodePNGInfo</span><span class="o">*</span><span class="w"> </span><span class="n">info</span><span class="p">);</span><span class="w"> </span><span class="cm">/*use this to clear the texts again after you filled them in*/</span><span class="w"></span>

<span class="kt">unsigned</span><span class="w"> </span><span class="nf">lodepng_add_itext</span><span class="p">(</span><span class="n">LodePNGInfo</span><span class="o">*</span><span class="w"> </span><span class="n">info</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">langtag</span><span class="p">,</span><span class="w"></span>
<span class="w">                           </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">transkey</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">str</span><span class="p">);</span><span class="w"> </span><span class="cm">/*push back the 4 texts of 1 chunk at once*/</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">lodepng_clear_itext</span><span class="p">(</span><span class="n">LodePNGInfo</span><span class="o">*</span><span class="w"> </span><span class="n">info</span><span class="p">);</span><span class="w"> </span><span class="cm">/*use this to clear the itexts again after you filled them in*/</span><span class="w"></span>

<span class="cm">/*replaces if exists*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">lodepng_set_icc</span><span class="p">(</span><span class="n">LodePNGInfo</span><span class="o">*</span><span class="w"> </span><span class="n">info</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">profile</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">profile_size</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">lodepng_clear_icc</span><span class="p">(</span><span class="n">LodePNGInfo</span><span class="o">*</span><span class="w"> </span><span class="n">info</span><span class="p">);</span><span class="w"> </span><span class="cm">/*use this to clear the texts again after you filled them in*/</span><span class="w"></span>
<span class="cp">#endif </span><span class="cm">/*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm">Converts raw buffer from one color type to another color type, based on</span>
<span class="cm">LodePNGColorMode structs to describe the input and output color type.</span>
<span class="cm">See the reference manual at the end of this header file to see which color conversions are supported.</span>
<span class="cm">return value = LodePNG error code (0 if all went ok, an error if the conversion isn&#39;t supported)</span>
<span class="cm">The out buffer must have size (w * h * bpp + 7) / 8, where bpp is the bits per pixel</span>
<span class="cm">of the output color type (lodepng_get_bpp).</span>
<span class="cm">For &lt; 8 bpp images, there should not be padding bits at the end of scanlines.</span>
<span class="cm">For 16-bit per channel colors, uses big endian format like PNG does.</span>
<span class="cm">Return value is LodePNG error code</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">lodepng_convert</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"></span>
<span class="w">                         </span><span class="k">const</span><span class="w"> </span><span class="n">LodePNGColorMode</span><span class="o">*</span><span class="w"> </span><span class="n">mode_out</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">LodePNGColorMode</span><span class="o">*</span><span class="w"> </span><span class="n">mode_in</span><span class="p">,</span><span class="w"></span>
<span class="w">                         </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">h</span><span class="p">);</span><span class="w"></span>

<span class="cp">#ifdef LODEPNG_COMPILE_DECODER</span>
<span class="cm">/*</span>
<span class="cm">Settings for the decoder. This contains settings for the PNG and the Zlib</span>
<span class="cm">decoder, but not the Info settings from the Info structs.</span>
<span class="cm">*/</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">LodePNGDecoderSettings</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">LodePNGDecompressSettings</span><span class="w"> </span><span class="n">zlibsettings</span><span class="p">;</span><span class="w"> </span><span class="cm">/*in here is the setting to ignore Adler32 checksums*/</span><span class="w"></span>

<span class="w">  </span><span class="cm">/* Check LodePNGDecompressSettings for more ignorable errors such as ignore_adler32 */</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">ignore_crc</span><span class="p">;</span><span class="w"> </span><span class="cm">/*ignore CRC checksums*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">ignore_critical</span><span class="p">;</span><span class="w"> </span><span class="cm">/*ignore unknown critical chunks*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">ignore_end</span><span class="p">;</span><span class="w"> </span><span class="cm">/*ignore issues at end of file if possible (missing IEND chunk, too large chunk, ...)*/</span><span class="w"></span>
<span class="w">  </span><span class="cm">/* TODO: make a system involving warnings with levels and a strict mode instead. Other potentially recoverable</span>
<span class="cm">     errors: srgb rendering intent value, size of content of ancillary chunks, more than 79 characters for some</span>
<span class="cm">     strings, placement/combination rules for ancillary chunks, crc of unknown chunks, allowed characters</span>
<span class="cm">     in string keys, etc... */</span><span class="w"></span>

<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">color_convert</span><span class="p">;</span><span class="w"> </span><span class="cm">/*whether to convert the PNG to the color type you want. Default: yes*/</span><span class="w"></span>

<span class="cp">#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">read_text_chunks</span><span class="p">;</span><span class="w"> </span><span class="cm">/*if false but remember_unknown_chunks is true, they&#39;re stored in the unknown chunks*/</span><span class="w"></span>
<span class="w">  </span><span class="cm">/*store all bytes from unknown chunks in the LodePNGInfo (off by default, useful for a png editor)*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">remember_unknown_chunks</span><span class="p">;</span><span class="w"></span>
<span class="cp">#endif </span><span class="cm">/*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/</span><span class="cp"></span>
<span class="p">}</span><span class="w"> </span><span class="n">LodePNGDecoderSettings</span><span class="p">;</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">lodepng_decoder_settings_init</span><span class="p">(</span><span class="n">LodePNGDecoderSettings</span><span class="o">*</span><span class="w"> </span><span class="n">settings</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif </span><span class="cm">/*LODEPNG_COMPILE_DECODER*/</span><span class="cp"></span>

<span class="cp">#ifdef LODEPNG_COMPILE_ENCODER</span>
<span class="cm">/*automatically use color type with less bits per pixel if losslessly possible. Default: AUTO*/</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">LodePNGFilterStrategy</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="cm">/*every filter at zero*/</span><span class="w"></span>
<span class="w">  </span><span class="n">LFS_ZERO</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="cm">/*every filter at 1, 2, 3 or 4 (paeth), unlike LFS_ZERO not a good choice, but for testing*/</span><span class="w"></span>
<span class="w">  </span><span class="n">LFS_ONE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">LFS_TWO</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">LFS_THREE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">LFS_FOUR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="cm">/*Use filter that gives minimum sum, as described in the official PNG filter heuristic.*/</span><span class="w"></span>
<span class="w">  </span><span class="n">LFS_MINSUM</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="cm">/*Use the filter type that gives smallest Shannon entropy for this scanline. Depending</span>
<span class="cm">  on the image, this is better or worse than minsum.*/</span><span class="w"></span>
<span class="w">  </span><span class="n">LFS_ENTROPY</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="cm">/*</span>
<span class="cm">  Brute-force-search PNG filters by compressing each filter for each scanline.</span>
<span class="cm">  Experimental, very slow, and only rarely gives better compression than MINSUM.</span>
<span class="cm">  */</span><span class="w"></span>
<span class="w">  </span><span class="n">LFS_BRUTE_FORCE</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="cm">/*use predefined_filters buffer: you specify the filter type for each scanline*/</span><span class="w"></span>
<span class="w">  </span><span class="n">LFS_PREDEFINED</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">LodePNGFilterStrategy</span><span class="p">;</span><span class="w"></span>

<span class="cm">/*Gives characteristics about the integer RGBA colors of the image (count, alpha channel usage, bit depth, ...),</span>
<span class="cm">which helps decide which color model to use for encoding.</span>
<span class="cm">Used internally by default if &quot;auto_convert&quot; is enabled. Public because it&#39;s useful for custom algorithms.*/</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">LodePNGColorStats</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">colored</span><span class="p">;</span><span class="w"> </span><span class="cm">/*not grayscale*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">key</span><span class="p">;</span><span class="w"> </span><span class="cm">/*image is not opaque and color key is possible instead of full alpha*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">key_r</span><span class="p">;</span><span class="w"> </span><span class="cm">/*key values, always as 16-bit, in 8-bit case the byte is duplicated, e.g. 65535 means 255*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">key_g</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">key_b</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">alpha</span><span class="p">;</span><span class="w"> </span><span class="cm">/*image is not opaque and alpha channel or alpha palette required*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">numcolors</span><span class="p">;</span><span class="w"> </span><span class="cm">/*amount of colors, up to 257. Not valid if bits == 16 or allow_palette is disabled.*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">palette</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span><span class="w"> </span><span class="cm">/*Remembers up to the first 256 RGBA colors, in no particular order, only valid when numcolors is valid*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">bits</span><span class="p">;</span><span class="w"> </span><span class="cm">/*bits per channel (not for palette). 1,2 or 4 for grayscale only. 16 if 16-bit per channel required.*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">numpixels</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="cm">/*user settings for computing/using the stats*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">allow_palette</span><span class="p">;</span><span class="w"> </span><span class="cm">/*default 1. if 0, disallow choosing palette colortype in auto_choose_color, and don&#39;t count numcolors*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">allow_greyscale</span><span class="p">;</span><span class="w"> </span><span class="cm">/*default 1. if 0, choose RGB or RGBA even if the image only has gray colors*/</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">LodePNGColorStats</span><span class="p">;</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">lodepng_color_stats_init</span><span class="p">(</span><span class="n">LodePNGColorStats</span><span class="o">*</span><span class="w"> </span><span class="n">stats</span><span class="p">);</span><span class="w"></span>

<span class="cm">/*Get a LodePNGColorStats of the image. The stats must already have been inited.</span>
<span class="cm">Returns error code (e.g. alloc fail) or 0 if ok.*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">lodepng_compute_color_stats</span><span class="p">(</span><span class="n">LodePNGColorStats</span><span class="o">*</span><span class="w"> </span><span class="n">stats</span><span class="p">,</span><span class="w"></span>
<span class="w">                                     </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">image</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">h</span><span class="p">,</span><span class="w"></span>
<span class="w">                                     </span><span class="k">const</span><span class="w"> </span><span class="n">LodePNGColorMode</span><span class="o">*</span><span class="w"> </span><span class="n">mode_in</span><span class="p">);</span><span class="w"></span>

<span class="cm">/*Settings for the encoder.*/</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">LodePNGEncoderSettings</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">LodePNGCompressSettings</span><span class="w"> </span><span class="n">zlibsettings</span><span class="p">;</span><span class="w"> </span><span class="cm">/*settings for the zlib encoder, such as window size, ...*/</span><span class="w"></span>

<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">auto_convert</span><span class="p">;</span><span class="w"> </span><span class="cm">/*automatically choose output PNG color type. Default: true*/</span><span class="w"></span>

<span class="w">  </span><span class="cm">/*If true, follows the official PNG heuristic: if the PNG uses a palette or lower than</span>
<span class="cm">  8 bit depth, set all filters to zero. Otherwise use the filter_strategy. Note that to</span>
<span class="cm">  completely follow the official PNG heuristic, filter_palette_zero must be true and</span>
<span class="cm">  filter_strategy must be LFS_MINSUM*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">filter_palette_zero</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="cm">/*Which filter strategy to use when not using zeroes due to filter_palette_zero.</span>
<span class="cm">  Set filter_palette_zero to 0 to ensure always using your chosen strategy. Default: LFS_MINSUM*/</span><span class="w"></span>
<span class="w">  </span><span class="n">LodePNGFilterStrategy</span><span class="w"> </span><span class="n">filter_strategy</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="cm">/*used if filter_strategy is LFS_PREDEFINED. In that case, this must point to a buffer with</span>
<span class="cm">  the same length as the amount of scanlines in the image, and each value must &lt;= 5. You</span>
<span class="cm">  have to cleanup this buffer, LodePNG will never free it. Don&#39;t forget that filter_palette_zero</span>
<span class="cm">  must be set to 0 to ensure this is also used on palette or low bitdepth images.*/</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">predefined_filters</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="cm">/*force creating a PLTE chunk if colortype is 2 or 6 (= a suggested palette).</span>
<span class="cm">  If colortype is 3, PLTE is _always_ created.*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">force_palette</span><span class="p">;</span><span class="w"></span>
<span class="cp">#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS</span>
<span class="w">  </span><span class="cm">/*add LodePNG identifier and version as a text chunk, for debugging*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">add_id</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="cm">/*encode text chunks as zTXt chunks instead of tEXt chunks, and use compression in iTXt chunks*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">text_compression</span><span class="p">;</span><span class="w"></span>
<span class="cp">#endif </span><span class="cm">/*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/</span><span class="cp"></span>
<span class="p">}</span><span class="w"> </span><span class="n">LodePNGEncoderSettings</span><span class="p">;</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">lodepng_encoder_settings_init</span><span class="p">(</span><span class="n">LodePNGEncoderSettings</span><span class="o">*</span><span class="w"> </span><span class="n">settings</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif </span><span class="cm">/*LODEPNG_COMPILE_ENCODER*/</span><span class="cp"></span>


<span class="cp">#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER)</span>
<span class="cm">/*The settings, state and information for extended encoding and decoding.*/</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">LodePNGState</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="cp">#ifdef LODEPNG_COMPILE_DECODER</span>
<span class="w">  </span><span class="n">LodePNGDecoderSettings</span><span class="w"> </span><span class="n">decoder</span><span class="p">;</span><span class="w"> </span><span class="cm">/*the decoding settings*/</span><span class="w"></span>
<span class="cp">#endif </span><span class="cm">/*LODEPNG_COMPILE_DECODER*/</span><span class="cp"></span>
<span class="cp">#ifdef LODEPNG_COMPILE_ENCODER</span>
<span class="w">  </span><span class="n">LodePNGEncoderSettings</span><span class="w"> </span><span class="n">encoder</span><span class="p">;</span><span class="w"> </span><span class="cm">/*the encoding settings*/</span><span class="w"></span>
<span class="cp">#endif </span><span class="cm">/*LODEPNG_COMPILE_ENCODER*/</span><span class="cp"></span>
<span class="w">  </span><span class="n">LodePNGColorMode</span><span class="w"> </span><span class="n">info_raw</span><span class="p">;</span><span class="w"> </span><span class="cm">/*specifies the format in which you would like to get the raw pixel buffer*/</span><span class="w"></span>
<span class="w">  </span><span class="n">LodePNGInfo</span><span class="w"> </span><span class="n">info_png</span><span class="p">;</span><span class="w"> </span><span class="cm">/*info of the PNG image obtained after decoding*/</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">error</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">LodePNGState</span><span class="p">;</span><span class="w"></span>

<span class="cm">/*init, cleanup and copy functions to use with this struct*/</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">lodepng_state_init</span><span class="p">(</span><span class="n">LodePNGState</span><span class="o">*</span><span class="w"> </span><span class="n">state</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">lodepng_state_cleanup</span><span class="p">(</span><span class="n">LodePNGState</span><span class="o">*</span><span class="w"> </span><span class="n">state</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">lodepng_state_copy</span><span class="p">(</span><span class="n">LodePNGState</span><span class="o">*</span><span class="w"> </span><span class="n">dest</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">LodePNGState</span><span class="o">*</span><span class="w"> </span><span class="n">source</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif </span><span class="cm">/* defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER) */</span><span class="cp"></span>

<span class="cp">#ifdef LODEPNG_COMPILE_DECODER</span>
<span class="cm">/*</span>
<span class="cm">Same as lodepng_decode_memory, but uses a LodePNGState to allow custom settings and</span>
<span class="cm">getting much more information about the PNG image and color mode.</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">lodepng_decode</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="o">*</span><span class="w"> </span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="o">*</span><span class="w"> </span><span class="n">h</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="n">LodePNGState</span><span class="o">*</span><span class="w"> </span><span class="n">state</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">insize</span><span class="p">);</span><span class="w"></span>

<span class="cm">/*</span>
<span class="cm">Read the PNG header, but not the actual data. This returns only the information</span>
<span class="cm">that is in the IHDR chunk of the PNG, such as width, height and color type. The</span>
<span class="cm">information is placed in the info_png field of the LodePNGState.</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">lodepng_inspect</span><span class="p">(</span><span class="kt">unsigned</span><span class="o">*</span><span class="w"> </span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="o">*</span><span class="w"> </span><span class="n">h</span><span class="p">,</span><span class="w"></span>
<span class="w">                         </span><span class="n">LodePNGState</span><span class="o">*</span><span class="w"> </span><span class="n">state</span><span class="p">,</span><span class="w"></span>
<span class="w">                         </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">insize</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif </span><span class="cm">/*LODEPNG_COMPILE_DECODER*/</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm">Reads one metadata chunk (other than IHDR) of the PNG file and outputs what it</span>
<span class="cm">read in the state. Returns error code on failure.</span>
<span class="cm">Use lodepng_inspect first with a new state, then e.g. lodepng_chunk_find_const</span>
<span class="cm">to find the desired chunk type, and if non null use lodepng_inspect_chunk (with</span>
<span class="cm">chunk_pointer - start_of_file as pos).</span>
<span class="cm">Supports most metadata chunks from the PNG standard (gAMA, bKGD, tEXt, ...).</span>
<span class="cm">Ignores unsupported, unknown, non-metadata or IHDR chunks (without error).</span>
<span class="cm">Requirements: &amp;in[pos] must point to start of a chunk, must use regular</span>
<span class="cm">lodepng_inspect first since format of most other chunks depends on IHDR, and if</span>
<span class="cm">there is a PLTE chunk, that one must be inspected before tRNS or bKGD.</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">lodepng_inspect_chunk</span><span class="p">(</span><span class="n">LodePNGState</span><span class="o">*</span><span class="w"> </span><span class="n">state</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span><span class="w"></span>
<span class="w">                               </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">insize</span><span class="p">);</span><span class="w"></span>

<span class="cp">#ifdef LODEPNG_COMPILE_ENCODER</span>
<span class="cm">/*This function allocates the out buffer with standard malloc and stores the size in *outsize.*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">lodepng_encode</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="o">*</span><span class="w"> </span><span class="n">outsize</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">image</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">h</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="n">LodePNGState</span><span class="o">*</span><span class="w"> </span><span class="n">state</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif </span><span class="cm">/*LODEPNG_COMPILE_ENCODER*/</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm">The lodepng_chunk functions are normally not needed, except to traverse the</span>
<span class="cm">unknown chunks stored in the LodePNGInfo struct, or add new ones to it.</span>
<span class="cm">It also allows traversing the chunks of an encoded PNG file yourself.</span>

<span class="cm">The chunk pointer always points to the beginning of the chunk itself, that is</span>
<span class="cm">the first byte of the 4 length bytes.</span>

<span class="cm">In the PNG file format, chunks have the following format:</span>
<span class="cm">-4 bytes length: length of the data of the chunk in bytes (chunk itself is 12 bytes longer)</span>
<span class="cm">-4 bytes chunk type (ASCII a-z,A-Z only, see below)</span>
<span class="cm">-length bytes of data (may be 0 bytes if length was 0)</span>
<span class="cm">-4 bytes of CRC, computed on chunk name + data</span>

<span class="cm">The first chunk starts at the 8th byte of the PNG file, the entire rest of the file</span>
<span class="cm">exists out of concatenated chunks with the above format.</span>

<span class="cm">PNG standard chunk ASCII naming conventions:</span>
<span class="cm">-First byte: uppercase = critical, lowercase = ancillary</span>
<span class="cm">-Second byte: uppercase = public, lowercase = private</span>
<span class="cm">-Third byte: must be uppercase</span>
<span class="cm">-Fourth byte: uppercase = unsafe to copy, lowercase = safe to copy</span>
<span class="cm">*/</span><span class="w"></span>

<span class="cm">/*</span>
<span class="cm">Gets the length of the data of the chunk. Total chunk length has 12 bytes more.</span>
<span class="cm">There must be at least 4 bytes to read from. If the result value is too large,</span>
<span class="cm">it may be corrupt data.</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">lodepng_chunk_length</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">chunk</span><span class="p">);</span><span class="w"></span>

<span class="cm">/*puts the 4-byte type in null terminated string*/</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">lodepng_chunk_type</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="n">type</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">chunk</span><span class="p">);</span><span class="w"></span>

<span class="cm">/*check if the type is the given type*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="nf">lodepng_chunk_type_equals</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">chunk</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">type</span><span class="p">);</span><span class="w"></span>

<span class="cm">/*0: it&#39;s one of the critical chunk types, 1: it&#39;s an ancillary chunk (see PNG standard)*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="nf">lodepng_chunk_ancillary</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">chunk</span><span class="p">);</span><span class="w"></span>

<span class="cm">/*0: public, 1: private (see PNG standard)*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="nf">lodepng_chunk_private</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">chunk</span><span class="p">);</span><span class="w"></span>

<span class="cm">/*0: the chunk is unsafe to copy, 1: the chunk is safe to copy (see PNG standard)*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="nf">lodepng_chunk_safetocopy</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">chunk</span><span class="p">);</span><span class="w"></span>

<span class="cm">/*get pointer to the data of the chunk, where the input points to the header of the chunk*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="nf">lodepng_chunk_data</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">chunk</span><span class="p">);</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="nf">lodepng_chunk_data_const</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">chunk</span><span class="p">);</span><span class="w"></span>

<span class="cm">/*returns 0 if the crc is correct, 1 if it&#39;s incorrect (0 for OK as usual!)*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">lodepng_chunk_check_crc</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">chunk</span><span class="p">);</span><span class="w"></span>

<span class="cm">/*generates the correct CRC from the data and puts it in the last 4 bytes of the chunk*/</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">lodepng_chunk_generate_crc</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">chunk</span><span class="p">);</span><span class="w"></span>

<span class="cm">/*</span>
<span class="cm">Iterate to next chunks, allows iterating through all chunks of the PNG file.</span>
<span class="cm">Input must be at the beginning of a chunk (result of a previous lodepng_chunk_next call,</span>
<span class="cm">or the 8th byte of a PNG file which always has the first chunk), or alternatively may</span>
<span class="cm">point to the first byte of the PNG file (which is not a chunk but the magic header, the</span>
<span class="cm">function will then skip over it and return the first real chunk).</span>
<span class="cm">Will output pointer to the start of the next chunk, or at or beyond end of the file if there</span>
<span class="cm">is no more chunk after this or possibly if the chunk is corrupt.</span>
<span class="cm">Start this process at the 8th byte of the PNG file.</span>
<span class="cm">In a non-corrupt PNG file, the last chunk should have name &quot;IEND&quot;.</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="nf">lodepng_chunk_next</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">chunk</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">end</span><span class="p">);</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="nf">lodepng_chunk_next_const</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">chunk</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">end</span><span class="p">);</span><span class="w"></span>

<span class="cm">/*Finds the first chunk with the given type in the range [chunk, end), or returns NULL if not found.*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="nf">lodepng_chunk_find</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">chunk</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">end</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">type</span><span class="p">[</span><span class="mi">5</span><span class="p">]);</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="nf">lodepng_chunk_find_const</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">chunk</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">end</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">type</span><span class="p">[</span><span class="mi">5</span><span class="p">]);</span><span class="w"></span>

<span class="cm">/*</span>
<span class="cm">Appends chunk to the data in out. The given chunk should already have its chunk header.</span>
<span class="cm">The out variable and outsize are updated to reflect the new reallocated buffer.</span>
<span class="cm">Returns error code (0 if it went ok)</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">lodepng_chunk_append</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="o">*</span><span class="w"> </span><span class="n">outsize</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">chunk</span><span class="p">);</span><span class="w"></span>

<span class="cm">/*</span>
<span class="cm">Appends new chunk to out. The chunk to append is given by giving its length, type</span>
<span class="cm">and data separately. The type is a 4-letter string.</span>
<span class="cm">The out variable and outsize are updated to reflect the new reallocated buffer.</span>
<span class="cm">Returne error code (0 if it went ok)</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">lodepng_chunk_create</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="o">*</span><span class="w"> </span><span class="n">outsize</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">length</span><span class="p">,</span><span class="w"></span>
<span class="w">                              </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">);</span><span class="w"></span>


<span class="cm">/*Calculate CRC32 of buffer*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">lodepng_crc32</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif </span><span class="cm">/*LODEPNG_COMPILE_PNG*/</span><span class="cp"></span>


<span class="cp">#ifdef LODEPNG_COMPILE_ZLIB</span>
<span class="cm">/*</span>
<span class="cm">This zlib part can be used independently to zlib compress and decompress a</span>
<span class="cm">buffer. It cannot be used to create gzip files however, and it only supports the</span>
<span class="cm">part of zlib that is required for PNG, it does not support dictionaries.</span>
<span class="cm">*/</span><span class="w"></span>

<span class="cp">#ifdef LODEPNG_COMPILE_DECODER</span>
<span class="cm">/*Inflate a buffer. Inflate is the decompression step of deflate. Out buffer must be freed after use.*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">lodepng_inflate</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="o">*</span><span class="w"> </span><span class="n">outsize</span><span class="p">,</span><span class="w"></span>
<span class="w">                         </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">insize</span><span class="p">,</span><span class="w"></span>
<span class="w">                         </span><span class="k">const</span><span class="w"> </span><span class="n">LodePNGDecompressSettings</span><span class="o">*</span><span class="w"> </span><span class="n">settings</span><span class="p">);</span><span class="w"></span>

<span class="cm">/*</span>
<span class="cm">Decompresses Zlib data. Reallocates the out buffer and appends the data. The</span>
<span class="cm">data must be according to the zlib specification.</span>
<span class="cm">Either, *out must be NULL and *outsize must be 0, or, *out must be a valid</span>
<span class="cm">buffer and *outsize its size in bytes. out must be freed by user after usage.</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">lodepng_zlib_decompress</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="o">*</span><span class="w"> </span><span class="n">outsize</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">insize</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="k">const</span><span class="w"> </span><span class="n">LodePNGDecompressSettings</span><span class="o">*</span><span class="w"> </span><span class="n">settings</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif </span><span class="cm">/*LODEPNG_COMPILE_DECODER*/</span><span class="cp"></span>

<span class="cp">#ifdef LODEPNG_COMPILE_ENCODER</span>
<span class="cm">/*</span>
<span class="cm">Compresses data with Zlib. Reallocates the out buffer and appends the data.</span>
<span class="cm">Zlib adds a small header and trailer around the deflate data.</span>
<span class="cm">The data is output in the format of the zlib specification.</span>
<span class="cm">Either, *out must be NULL and *outsize must be 0, or, *out must be a valid</span>
<span class="cm">buffer and *outsize its size in bytes. out must be freed by user after usage.</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">lodepng_zlib_compress</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="o">*</span><span class="w"> </span><span class="n">outsize</span><span class="p">,</span><span class="w"></span>
<span class="w">                               </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">insize</span><span class="p">,</span><span class="w"></span>
<span class="w">                               </span><span class="k">const</span><span class="w"> </span><span class="n">LodePNGCompressSettings</span><span class="o">*</span><span class="w"> </span><span class="n">settings</span><span class="p">);</span><span class="w"></span>

<span class="cm">/*</span>
<span class="cm">Find length-limited Huffman code for given frequencies. This function is in the</span>
<span class="cm">public interface only for tests, it&#39;s used internally by lodepng_deflate.</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">lodepng_huffman_code_lengths</span><span class="p">(</span><span class="kt">unsigned</span><span class="o">*</span><span class="w"> </span><span class="n">lengths</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="o">*</span><span class="w"> </span><span class="n">frequencies</span><span class="p">,</span><span class="w"></span>
<span class="w">                                      </span><span class="kt">size_t</span><span class="w"> </span><span class="n">numcodes</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">maxbitlen</span><span class="p">);</span><span class="w"></span>

<span class="cm">/*Compress a buffer with deflate. See RFC 1951. Out buffer must be freed after use.*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">lodepng_deflate</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="o">*</span><span class="w"> </span><span class="n">outsize</span><span class="p">,</span><span class="w"></span>
<span class="w">                         </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">insize</span><span class="p">,</span><span class="w"></span>
<span class="w">                         </span><span class="k">const</span><span class="w"> </span><span class="n">LodePNGCompressSettings</span><span class="o">*</span><span class="w"> </span><span class="n">settings</span><span class="p">);</span><span class="w"></span>

<span class="cp">#endif </span><span class="cm">/*LODEPNG_COMPILE_ENCODER*/</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/*LODEPNG_COMPILE_ZLIB*/</span><span class="cp"></span>

<span class="cp">#ifdef LODEPNG_COMPILE_DISK</span>
<span class="cm">/*</span>
<span class="cm">Load a file from disk into buffer. The function allocates the out buffer, and</span>
<span class="cm">after usage you should free it.</span>
<span class="cm">out: output parameter, contains pointer to loaded buffer.</span>
<span class="cm">outsize: output parameter, size of the allocated out buffer</span>
<span class="cm">filename: the path to the file to load</span>
<span class="cm">return value: error code (0 means ok)</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">lodepng_load_file</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="o">*</span><span class="w"> </span><span class="n">outsize</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">);</span><span class="w"></span>

<span class="cm">/*</span>
<span class="cm">Save a file from buffer to disk. Warning, if it exists, this function overwrites</span>
<span class="cm">the file without warning!</span>
<span class="cm">buffer: the buffer to write</span>
<span class="cm">buffersize: size of the buffer to write</span>
<span class="cm">filename: the path to the file to save to</span>
<span class="cm">return value: error code (0 means ok)</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">lodepng_save_file</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">buffersize</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif </span><span class="cm">/*LODEPNG_COMPILE_DISK*/</span><span class="cp"></span>

<span class="cp">#ifdef LODEPNG_COMPILE_CPP</span>
<span class="cm">/* The LodePNG C++ wrapper uses std::vectors instead of manually allocated memory buffers. */</span><span class="w"></span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">lodepng</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="cp">#ifdef LODEPNG_COMPILE_PNG</span>
<span class="k">class</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">LodePNGState</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="n">State</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">State</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">State</span><span class="o">&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="o">~</span><span class="n">State</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">State</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">State</span><span class="o">&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">);</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="cp">#ifdef LODEPNG_COMPILE_DECODER</span>
<span class="cm">/* Same as other lodepng::decode, but using a State for more settings and information. */</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">decode</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="o">&amp;</span><span class="w"> </span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="o">&amp;</span><span class="w"> </span><span class="n">h</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">State</span><span class="o">&amp;</span><span class="w"> </span><span class="n">state</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">insize</span><span class="p">);</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">decode</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="o">&amp;</span><span class="w"> </span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="o">&amp;</span><span class="w"> </span><span class="n">h</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">State</span><span class="o">&amp;</span><span class="w"> </span><span class="n">state</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">in</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif </span><span class="cm">/*LODEPNG_COMPILE_DECODER*/</span><span class="cp"></span>

<span class="cp">#ifdef LODEPNG_COMPILE_ENCODER</span>
<span class="cm">/* Same as other lodepng::encode, but using a State for more settings and information. */</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">encode</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">h</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">State</span><span class="o">&amp;</span><span class="w"> </span><span class="n">state</span><span class="p">);</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">encode</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">h</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">State</span><span class="o">&amp;</span><span class="w"> </span><span class="n">state</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif </span><span class="cm">/*LODEPNG_COMPILE_ENCODER*/</span><span class="cp"></span>

<span class="cp">#ifdef LODEPNG_COMPILE_DISK</span>
<span class="cm">/*</span>
<span class="cm">Load a file from disk into an std::vector.</span>
<span class="cm">return value: error code (0 means ok)</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">load_file</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">filename</span><span class="p">);</span><span class="w"></span>

<span class="cm">/*</span>
<span class="cm">Save the binary data in an std::vector to a file on disk. The file is overwritten</span>
<span class="cm">without warning.</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">save_file</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">filename</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif </span><span class="cm">/* LODEPNG_COMPILE_DISK */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* LODEPNG_COMPILE_PNG */</span><span class="cp"></span>

<span class="cp">#ifdef LODEPNG_COMPILE_ZLIB</span>
<span class="cp">#ifdef LODEPNG_COMPILE_DECODER</span>
<span class="cm">/* Zlib-decompress an unsigned char buffer */</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">decompress</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">insize</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="k">const</span><span class="w"> </span><span class="n">LodePNGDecompressSettings</span><span class="o">&amp;</span><span class="w"> </span><span class="n">settings</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lodepng_default_decompress_settings</span><span class="p">);</span><span class="w"></span>

<span class="cm">/* Zlib-decompress an std::vector */</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">decompress</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="k">const</span><span class="w"> </span><span class="n">LodePNGDecompressSettings</span><span class="o">&amp;</span><span class="w"> </span><span class="n">settings</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lodepng_default_decompress_settings</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif </span><span class="cm">/* LODEPNG_COMPILE_DECODER */</span><span class="cp"></span>

<span class="cp">#ifdef LODEPNG_COMPILE_ENCODER</span>
<span class="cm">/* Zlib-compress an unsigned char buffer */</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">compress</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">insize</span><span class="p">,</span><span class="w"></span>
<span class="w">                  </span><span class="k">const</span><span class="w"> </span><span class="n">LodePNGCompressSettings</span><span class="o">&amp;</span><span class="w"> </span><span class="n">settings</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lodepng_default_compress_settings</span><span class="p">);</span><span class="w"></span>

<span class="cm">/* Zlib-compress an std::vector */</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">compress</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"></span>
<span class="w">                  </span><span class="k">const</span><span class="w"> </span><span class="n">LodePNGCompressSettings</span><span class="o">&amp;</span><span class="w"> </span><span class="n">settings</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lodepng_default_compress_settings</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif </span><span class="cm">/* LODEPNG_COMPILE_ENCODER */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* LODEPNG_COMPILE_ZLIB */</span><span class="cp"></span>
<span class="p">}</span><span class="w"> </span><span class="cm">/* namespace lodepng */</span><span class="w"></span>
<span class="cp">#endif </span><span class="cm">/*LODEPNG_COMPILE_CPP*/</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm">TODO:</span>
<span class="cm">[.] test if there are no memory leaks or security exploits - done a lot but needs to be checked often</span>
<span class="cm">[.] check compatibility with various compilers  - done but needs to be redone for every newer version</span>
<span class="cm">[X] converting color to 16-bit per channel types</span>
<span class="cm">[X] support color profile chunk types (but never let them touch RGB values by default)</span>
<span class="cm">[ ] support all public PNG chunk types (almost done except sBIT, sPLT and hIST)</span>
<span class="cm">[ ] make sure encoder generates no chunks with size &gt; (2^31)-1</span>
<span class="cm">[ ] partial decoding (stream processing)</span>
<span class="cm">[X] let the &quot;isFullyOpaque&quot; function check color keys and transparent palettes too</span>
<span class="cm">[X] better name for the variables &quot;codes&quot;, &quot;codesD&quot;, &quot;codelengthcodes&quot;, &quot;clcl&quot; and &quot;lldl&quot;</span>
<span class="cm">[ ] allow treating some errors like warnings, when image is recoverable (e.g. 69, 57, 58)</span>
<span class="cm">[ ] make warnings like: oob palette, checksum fail, data after iend, wrong/unknown crit chunk, no null terminator in text, ...</span>
<span class="cm">[ ] error messages with line numbers (and version)</span>
<span class="cm">[ ] errors in state instead of as return code?</span>
<span class="cm">[ ] new errors/warnings like suspiciously big decompressed ztxt or iccp chunk</span>
<span class="cm">[ ] let the C++ wrapper catch exceptions coming from the standard library and return LodePNG error codes</span>
<span class="cm">[ ] allow user to provide custom color conversion functions, e.g. for premultiplied alpha, padding bits or not, ...</span>
<span class="cm">[ ] allow user to give data (void*) to custom allocator</span>
<span class="cm">[X] provide alternatives for C library functions not present on some platforms (memcpy, ...)</span>
<span class="cm">*/</span><span class="w"></span>

<span class="cp">#endif </span><span class="cm">/*LODEPNG_H inclusion guard*/</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm">LodePNG Documentation</span>
<span class="cm">---------------------</span>

<span class="cm">0. table of contents</span>
<span class="cm">--------------------</span>

<span class="cm">  1. about</span>
<span class="cm">   1.1. supported features</span>
<span class="cm">   1.2. features not supported</span>
<span class="cm">  2. C and C++ version</span>
<span class="cm">  3. security</span>
<span class="cm">  4. decoding</span>
<span class="cm">  5. encoding</span>
<span class="cm">  6. color conversions</span>
<span class="cm">    6.1. PNG color types</span>
<span class="cm">    6.2. color conversions</span>
<span class="cm">    6.3. padding bits</span>
<span class="cm">    6.4. A note about 16-bits per channel and endianness</span>
<span class="cm">  7. error values</span>
<span class="cm">  8. chunks and PNG editing</span>
<span class="cm">  9. compiler support</span>
<span class="cm">  10. examples</span>
<span class="cm">   10.1. decoder C++ example</span>
<span class="cm">   10.2. decoder C example</span>
<span class="cm">  11. state settings reference</span>
<span class="cm">  12. changes</span>
<span class="cm">  13. contact information</span>


<span class="cm">1. about</span>
<span class="cm">--------</span>

<span class="cm">PNG is a file format to store raster images losslessly with good compression,</span>
<span class="cm">supporting different color types and alpha channel.</span>

<span class="cm">LodePNG is a PNG codec according to the Portable Network Graphics (PNG)</span>
<span class="cm">Specification (Second Edition) - W3C Recommendation 10 November 2003.</span>

<span class="cm">The specifications used are:</span>

<span class="cm">*) Portable Network Graphics (PNG) Specification (Second Edition):</span>
<span class="cm">     http://www.w3.org/TR/2003/REC-PNG-20031110</span>
<span class="cm">*) RFC 1950 ZLIB Compressed Data Format version 3.3:</span>
<span class="cm">     http://www.gzip.org/zlib/rfc-zlib.html</span>
<span class="cm">*) RFC 1951 DEFLATE Compressed Data Format Specification ver 1.3:</span>
<span class="cm">     http://www.gzip.org/zlib/rfc-deflate.html</span>

<span class="cm">The most recent version of LodePNG can currently be found at</span>
<span class="cm">http://lodev.org/lodepng/</span>

<span class="cm">LodePNG works both in C (ISO C90) and C++, with a C++ wrapper that adds</span>
<span class="cm">extra functionality.</span>

<span class="cm">LodePNG exists out of two files:</span>
<span class="cm">-lodepng.h: the header file for both C and C++</span>
<span class="cm">-lodepng.c(pp): give it the name lodepng.c or lodepng.cpp (or .cc) depending on your usage</span>

<span class="cm">If you want to start using LodePNG right away without reading this doc, get the</span>
<span class="cm">examples from the LodePNG website to see how to use it in code, or check the</span>
<span class="cm">smaller examples in chapter 13 here.</span>

<span class="cm">LodePNG is simple but only supports the basic requirements. To achieve</span>
<span class="cm">simplicity, the following design choices were made: There are no dependencies</span>
<span class="cm">on any external library. There are functions to decode and encode a PNG with</span>
<span class="cm">a single function call, and extended versions of these functions taking a</span>
<span class="cm">LodePNGState struct allowing to specify or get more information. By default</span>
<span class="cm">the colors of the raw image are always RGB or RGBA, no matter what color type</span>
<span class="cm">the PNG file uses. To read and write files, there are simple functions to</span>
<span class="cm">convert the files to/from buffers in memory.</span>

<span class="cm">This all makes LodePNG suitable for loading textures in games, demos and small</span>
<span class="cm">programs, ... It&#39;s less suitable for full fledged image editors, loading PNGs</span>
<span class="cm">over network (it requires all the image data to be available before decoding can</span>
<span class="cm">begin), life-critical systems, ...</span>

<span class="cm">1.1. supported features</span>
<span class="cm">-----------------------</span>

<span class="cm">The following features are supported by the decoder:</span>

<span class="cm">*) decoding of PNGs with any color type, bit depth and interlace mode, to a 24- or 32-bit color raw image,</span>
<span class="cm">   or the same color type as the PNG</span>
<span class="cm">*) encoding of PNGs, from any raw image to 24- or 32-bit color, or the same color type as the raw image</span>
<span class="cm">*) Adam7 interlace and deinterlace for any color type</span>
<span class="cm">*) loading the image from harddisk or decoding it from a buffer from other sources than harddisk</span>
<span class="cm">*) support for alpha channels, including RGBA color model, translucent palettes and color keying</span>
<span class="cm">*) zlib decompression (inflate)</span>
<span class="cm">*) zlib compression (deflate)</span>
<span class="cm">*) CRC32 and ADLER32 checksums</span>
<span class="cm">*) colorimetric color profile conversions: currently experimentally available in lodepng_util.cpp only,</span>
<span class="cm">   plus alternatively ability to pass on chroma/gamma/ICC profile information to other color management system.</span>
<span class="cm">*) handling of unknown chunks, allowing making a PNG editor that stores custom and unknown chunks.</span>
<span class="cm">*) the following chunks are supported by both encoder and decoder:</span>
<span class="cm">    IHDR: header information</span>
<span class="cm">    PLTE: color palette</span>
<span class="cm">    IDAT: pixel data</span>
<span class="cm">    IEND: the final chunk</span>
<span class="cm">    tRNS: transparency for palettized images</span>
<span class="cm">    tEXt: textual information</span>
<span class="cm">    zTXt: compressed textual information</span>
<span class="cm">    iTXt: international textual information</span>
<span class="cm">    bKGD: suggested background color</span>
<span class="cm">    pHYs: physical dimensions</span>
<span class="cm">    tIME: modification time</span>
<span class="cm">    cHRM: RGB chromaticities</span>
<span class="cm">    gAMA: RGB gamma correction</span>
<span class="cm">    iCCP: ICC color profile</span>
<span class="cm">    sRGB: rendering intent</span>

<span class="cm">1.2. features not supported</span>
<span class="cm">---------------------------</span>

<span class="cm">The following features are _not_ supported:</span>

<span class="cm">*) some features needed to make a conformant PNG-Editor might be still missing.</span>
<span class="cm">*) partial loading/stream processing. All data must be available and is processed in one call.</span>
<span class="cm">*) The following public chunks are not (yet) supported but treated as unknown chunks by LodePNG:</span>
<span class="cm">    sBIT</span>
<span class="cm">    hIST</span>
<span class="cm">    sPLT</span>


<span class="cm">2. C and C++ version</span>
<span class="cm">--------------------</span>

<span class="cm">The C version uses buffers allocated with alloc that you need to free()</span>
<span class="cm">yourself. You need to use init and cleanup functions for each struct whenever</span>
<span class="cm">using a struct from the C version to avoid exploits and memory leaks.</span>

<span class="cm">The C++ version has extra functions with std::vectors in the interface and the</span>
<span class="cm">lodepng::State class which is a LodePNGState with constructor and destructor.</span>

<span class="cm">These files work without modification for both C and C++ compilers because all</span>
<span class="cm">the additional C++ code is in &quot;#ifdef __cplusplus&quot; blocks that make C-compilers</span>
<span class="cm">ignore it, and the C code is made to compile both with strict ISO C90 and C++.</span>

<span class="cm">To use the C++ version, you need to rename the source file to lodepng.cpp</span>
<span class="cm">(instead of lodepng.c), and compile it with a C++ compiler.</span>

<span class="cm">To use the C version, you need to rename the source file to lodepng.c (instead</span>
<span class="cm">of lodepng.cpp), and compile it with a C compiler.</span>


<span class="cm">3. Security</span>
<span class="cm">-----------</span>

<span class="cm">Even if carefully designed, it&#39;s always possible that LodePNG contains possible</span>
<span class="cm">exploits. If you discover one, please let me know, and it will be fixed.</span>

<span class="cm">When using LodePNG, care has to be taken with the C version of LodePNG, as well</span>
<span class="cm">as the C-style structs when working with C++. The following conventions are used</span>
<span class="cm">for all C-style structs:</span>

<span class="cm">-if a struct has a corresponding init function, always call the init function when making a new one</span>
<span class="cm">-if a struct has a corresponding cleanup function, call it before the struct disappears to avoid memory leaks</span>
<span class="cm">-if a struct has a corresponding copy function, use the copy function instead of &quot;=&quot;.</span>
<span class="cm"> The destination must also be inited already.</span>


<span class="cm">4. Decoding</span>
<span class="cm">-----------</span>

<span class="cm">Decoding converts a PNG compressed image to a raw pixel buffer.</span>

<span class="cm">Most documentation on using the decoder is at its declarations in the header</span>
<span class="cm">above. For C, simple decoding can be done with functions such as</span>
<span class="cm">lodepng_decode32, and more advanced decoding can be done with the struct</span>
<span class="cm">LodePNGState and lodepng_decode. For C++, all decoding can be done with the</span>
<span class="cm">various lodepng::decode functions, and lodepng::State can be used for advanced</span>
<span class="cm">features.</span>

<span class="cm">When using the LodePNGState, it uses the following fields for decoding:</span>
<span class="cm">*) LodePNGInfo info_png: it stores extra information about the PNG (the input) in here</span>
<span class="cm">*) LodePNGColorMode info_raw: here you can say what color mode of the raw image (the output) you want to get</span>
<span class="cm">*) LodePNGDecoderSettings decoder: you can specify a few extra settings for the decoder to use</span>

<span class="cm">LodePNGInfo info_png</span>
<span class="cm">--------------------</span>

<span class="cm">After decoding, this contains extra information of the PNG image, except the actual</span>
<span class="cm">pixels, width and height because these are already gotten directly from the decoder</span>
<span class="cm">functions.</span>

<span class="cm">It contains for example the original color type of the PNG image, text comments,</span>
<span class="cm">suggested background color, etc... More details about the LodePNGInfo struct are</span>
<span class="cm">at its declaration documentation.</span>

<span class="cm">LodePNGColorMode info_raw</span>
<span class="cm">-------------------------</span>

<span class="cm">When decoding, here you can specify which color type you want</span>
<span class="cm">the resulting raw image to be. If this is different from the colortype of the</span>
<span class="cm">PNG, then the decoder will automatically convert the result. This conversion</span>
<span class="cm">always works, except if you want it to convert a color PNG to grayscale or to</span>
<span class="cm">a palette with missing colors.</span>

<span class="cm">By default, 32-bit color is used for the result.</span>

<span class="cm">LodePNGDecoderSettings decoder</span>
<span class="cm">------------------------------</span>

<span class="cm">The settings can be used to ignore the errors created by invalid CRC and Adler32</span>
<span class="cm">chunks, and to disable the decoding of tEXt chunks.</span>

<span class="cm">There&#39;s also a setting color_convert, true by default. If false, no conversion</span>
<span class="cm">is done, the resulting data will be as it was in the PNG (after decompression)</span>
<span class="cm">and you&#39;ll have to puzzle the colors of the pixels together yourself using the</span>
<span class="cm">color type information in the LodePNGInfo.</span>


<span class="cm">5. Encoding</span>
<span class="cm">-----------</span>

<span class="cm">Encoding converts a raw pixel buffer to a PNG compressed image.</span>

<span class="cm">Most documentation on using the encoder is at its declarations in the header</span>
<span class="cm">above. For C, simple encoding can be done with functions such as</span>
<span class="cm">lodepng_encode32, and more advanced decoding can be done with the struct</span>
<span class="cm">LodePNGState and lodepng_encode. For C++, all encoding can be done with the</span>
<span class="cm">various lodepng::encode functions, and lodepng::State can be used for advanced</span>
<span class="cm">features.</span>

<span class="cm">Like the decoder, the encoder can also give errors. However it gives less errors</span>
<span class="cm">since the encoder input is trusted, the decoder input (a PNG image that could</span>
<span class="cm">be forged by anyone) is not trusted.</span>

<span class="cm">When using the LodePNGState, it uses the following fields for encoding:</span>
<span class="cm">*) LodePNGInfo info_png: here you specify how you want the PNG (the output) to be.</span>
<span class="cm">*) LodePNGColorMode info_raw: here you say what color type of the raw image (the input) has</span>
<span class="cm">*) LodePNGEncoderSettings encoder: you can specify a few settings for the encoder to use</span>

<span class="cm">LodePNGInfo info_png</span>
<span class="cm">--------------------</span>

<span class="cm">When encoding, you use this the opposite way as when decoding: for encoding,</span>
<span class="cm">you fill in the values you want the PNG to have before encoding. By default it&#39;s</span>
<span class="cm">not needed to specify a color type for the PNG since it&#39;s automatically chosen,</span>
<span class="cm">but it&#39;s possible to choose it yourself given the right settings.</span>

<span class="cm">The encoder will not always exactly match the LodePNGInfo struct you give,</span>
<span class="cm">it tries as close as possible. Some things are ignored by the encoder. The</span>
<span class="cm">encoder uses, for example, the following settings from it when applicable:</span>
<span class="cm">colortype and bitdepth, text chunks, time chunk, the color key, the palette, the</span>
<span class="cm">background color, the interlace method, unknown chunks, ...</span>

<span class="cm">When encoding to a PNG with colortype 3, the encoder will generate a PLTE chunk.</span>
<span class="cm">If the palette contains any colors for which the alpha channel is not 255 (so</span>
<span class="cm">there are translucent colors in the palette), it&#39;ll add a tRNS chunk.</span>

<span class="cm">LodePNGColorMode info_raw</span>
<span class="cm">-------------------------</span>

<span class="cm">You specify the color type of the raw image that you give to the input here,</span>
<span class="cm">including a possible transparent color key and palette you happen to be using in</span>
<span class="cm">your raw image data.</span>

<span class="cm">By default, 32-bit color is assumed, meaning your input has to be in RGBA</span>
<span class="cm">format with 4 bytes (unsigned chars) per pixel.</span>

<span class="cm">LodePNGEncoderSettings encoder</span>
<span class="cm">------------------------------</span>

<span class="cm">The following settings are supported (some are in sub-structs):</span>
<span class="cm">*) auto_convert: when this option is enabled, the encoder will</span>
<span class="cm">automatically choose the smallest possible color mode (including color key) that</span>
<span class="cm">can encode the colors of all pixels without information loss.</span>
<span class="cm">*) btype: the block type for LZ77. 0 = uncompressed, 1 = fixed huffman tree,</span>
<span class="cm">   2 = dynamic huffman tree (best compression). Should be 2 for proper</span>
<span class="cm">   compression.</span>
<span class="cm">*) use_lz77: whether or not to use LZ77 for compressed block types. Should be</span>
<span class="cm">   true for proper compression.</span>
<span class="cm">*) windowsize: the window size used by the LZ77 encoder (1 - 32768). Has value</span>
<span class="cm">   2048 by default, but can be set to 32768 for better, but slow, compression.</span>
<span class="cm">*) force_palette: if colortype is 2 or 6, you can make the encoder write a PLTE</span>
<span class="cm">   chunk if force_palette is true. This can used as suggested palette to convert</span>
<span class="cm">   to by viewers that don&#39;t support more than 256 colors (if those still exist)</span>
<span class="cm">*) add_id: add text chunk &quot;Encoder: LodePNG &lt;version&gt;&quot; to the image.</span>
<span class="cm">*) text_compression: default 1. If 1, it&#39;ll store texts as zTXt instead of tEXt chunks.</span>
<span class="cm">  zTXt chunks use zlib compression on the text. This gives a smaller result on</span>
<span class="cm">  large texts but a larger result on small texts (such as a single program name).</span>
<span class="cm">  It&#39;s all tEXt or all zTXt though, there&#39;s no separate setting per text yet.</span>


<span class="cm">6. color conversions</span>
<span class="cm">--------------------</span>

<span class="cm">An important thing to note about LodePNG, is that the color type of the PNG, and</span>
<span class="cm">the color type of the raw image, are completely independent. By default, when</span>
<span class="cm">you decode a PNG, you get the result as a raw image in the color type you want,</span>
<span class="cm">no matter whether the PNG was encoded with a palette, grayscale or RGBA color.</span>
<span class="cm">And if you encode an image, by default LodePNG will automatically choose the PNG</span>
<span class="cm">color type that gives good compression based on the values of colors and amount</span>
<span class="cm">of colors in the image. It can be configured to let you control it instead as</span>
<span class="cm">well, though.</span>

<span class="cm">To be able to do this, LodePNG does conversions from one color mode to another.</span>
<span class="cm">It can convert from almost any color type to any other color type, except the</span>
<span class="cm">following conversions: RGB to grayscale is not supported, and converting to a</span>
<span class="cm">palette when the palette doesn&#39;t have a required color is not supported. This is</span>
<span class="cm">not supported on purpose: this is information loss which requires a color</span>
<span class="cm">reduction algorithm that is beyond the scope of a PNG encoder (yes, RGB to gray</span>
<span class="cm">is easy, but there are multiple ways if you want to give some channels more</span>
<span class="cm">weight).</span>

<span class="cm">By default, when decoding, you get the raw image in 32-bit RGBA or 24-bit RGB</span>
<span class="cm">color, no matter what color type the PNG has. And by default when encoding,</span>
<span class="cm">LodePNG automatically picks the best color model for the output PNG, and expects</span>
<span class="cm">the input image to be 32-bit RGBA or 24-bit RGB. So, unless you want to control</span>
<span class="cm">the color format of the images yourself, you can skip this chapter.</span>

<span class="cm">6.1. PNG color types</span>
<span class="cm">--------------------</span>

<span class="cm">A PNG image can have many color types, ranging from 1-bit color to 64-bit color,</span>
<span class="cm">as well as palettized color modes. After the zlib decompression and unfiltering</span>
<span class="cm">in the PNG image is done, the raw pixel data will have that color type and thus</span>
<span class="cm">a certain amount of bits per pixel. If you want the output raw image after</span>
<span class="cm">decoding to have another color type, a conversion is done by LodePNG.</span>

<span class="cm">The PNG specification gives the following color types:</span>

<span class="cm">0: grayscale, bit depths 1, 2, 4, 8, 16</span>
<span class="cm">2: RGB, bit depths 8 and 16</span>
<span class="cm">3: palette, bit depths 1, 2, 4 and 8</span>
<span class="cm">4: grayscale with alpha, bit depths 8 and 16</span>
<span class="cm">6: RGBA, bit depths 8 and 16</span>

<span class="cm">Bit depth is the amount of bits per pixel per color channel. So the total amount</span>
<span class="cm">of bits per pixel is: amount of channels * bitdepth.</span>

<span class="cm">6.2. color conversions</span>
<span class="cm">----------------------</span>

<span class="cm">As explained in the sections about the encoder and decoder, you can specify</span>
<span class="cm">color types and bit depths in info_png and info_raw to change the default</span>
<span class="cm">behaviour.</span>

<span class="cm">If, when decoding, you want the raw image to be something else than the default,</span>
<span class="cm">you need to set the color type and bit depth you want in the LodePNGColorMode,</span>
<span class="cm">or the parameters colortype and bitdepth of the simple decoding function.</span>

<span class="cm">If, when encoding, you use another color type than the default in the raw input</span>
<span class="cm">image, you need to specify its color type and bit depth in the LodePNGColorMode</span>
<span class="cm">of the raw image, or use the parameters colortype and bitdepth of the simple</span>
<span class="cm">encoding function.</span>

<span class="cm">If, when encoding, you don&#39;t want LodePNG to choose the output PNG color type</span>
<span class="cm">but control it yourself, you need to set auto_convert in the encoder settings</span>
<span class="cm">to false, and specify the color type you want in the LodePNGInfo of the</span>
<span class="cm">encoder (including palette: it can generate a palette if auto_convert is true,</span>
<span class="cm">otherwise not).</span>

<span class="cm">If the input and output color type differ (whether user chosen or auto chosen),</span>
<span class="cm">LodePNG will do a color conversion, which follows the rules below, and may</span>
<span class="cm">sometimes result in an error.</span>

<span class="cm">To avoid some confusion:</span>
<span class="cm">-the decoder converts from PNG to raw image</span>
<span class="cm">-the encoder converts from raw image to PNG</span>
<span class="cm">-the colortype and bitdepth in LodePNGColorMode info_raw, are those of the raw image</span>
<span class="cm">-the colortype and bitdepth in the color field of LodePNGInfo info_png, are those of the PNG</span>
<span class="cm">-when encoding, the color type in LodePNGInfo is ignored if auto_convert</span>
<span class="cm"> is enabled, it is automatically generated instead</span>
<span class="cm">-when decoding, the color type in LodePNGInfo is set by the decoder to that of the original</span>
<span class="cm"> PNG image, but it can be ignored since the raw image has the color type you requested instead</span>
<span class="cm">-if the color type of the LodePNGColorMode and PNG image aren&#39;t the same, a conversion</span>
<span class="cm"> between the color types is done if the color types are supported. If it is not</span>
<span class="cm"> supported, an error is returned. If the types are the same, no conversion is done.</span>
<span class="cm">-even though some conversions aren&#39;t supported, LodePNG supports loading PNGs from any</span>
<span class="cm"> colortype and saving PNGs to any colortype, sometimes it just requires preparing</span>
<span class="cm"> the raw image correctly before encoding.</span>
<span class="cm">-both encoder and decoder use the same color converter.</span>

<span class="cm">The function lodepng_convert does the color conversion. It is available in the</span>
<span class="cm">interface but normally isn&#39;t needed since the encoder and decoder already call</span>
<span class="cm">it.</span>

<span class="cm">Non supported color conversions:</span>
<span class="cm">-color to grayscale when non-gray pixels are present: no error is thrown, but</span>
<span class="cm">the result will look ugly because only the red channel is taken (it assumes all</span>
<span class="cm">three channels are the same in this case so ignores green and blue). The reason</span>
<span class="cm">no error is given is to allow converting from three-channel grayscale images to</span>
<span class="cm">one-channel even if there are numerical imprecisions.</span>
<span class="cm">-anything to palette when the palette does not have an exact match for a from-color</span>
<span class="cm">in it: in this case an error is thrown</span>

<span class="cm">Supported color conversions:</span>
<span class="cm">-anything to 8-bit RGB, 8-bit RGBA, 16-bit RGB, 16-bit RGBA</span>
<span class="cm">-any gray or gray+alpha, to gray or gray+alpha</span>
<span class="cm">-anything to a palette, as long as the palette has the requested colors in it</span>
<span class="cm">-removing alpha channel</span>
<span class="cm">-higher to smaller bitdepth, and vice versa</span>

<span class="cm">If you want no color conversion to be done (e.g. for speed or control):</span>
<span class="cm">-In the encoder, you can make it save a PNG with any color type by giving the</span>
<span class="cm">raw color mode and LodePNGInfo the same color mode, and setting auto_convert to</span>
<span class="cm">false.</span>
<span class="cm">-In the decoder, you can make it store the pixel data in the same color type</span>
<span class="cm">as the PNG has, by setting the color_convert setting to false. Settings in</span>
<span class="cm">info_raw are then ignored.</span>

<span class="cm">6.3. padding bits</span>
<span class="cm">-----------------</span>

<span class="cm">In the PNG file format, if a less than 8-bit per pixel color type is used and the scanlines</span>
<span class="cm">have a bit amount that isn&#39;t a multiple of 8, then padding bits are used so that each</span>
<span class="cm">scanline starts at a fresh byte. But that is NOT true for the LodePNG raw input and output.</span>
<span class="cm">The raw input image you give to the encoder, and the raw output image you get from the decoder</span>
<span class="cm">will NOT have these padding bits, e.g. in the case of a 1-bit image with a width</span>
<span class="cm">of 7 pixels, the first pixel of the second scanline will the 8th bit of the first byte,</span>
<span class="cm">not the first bit of a new byte.</span>

<span class="cm">6.4. A note about 16-bits per channel and endianness</span>
<span class="cm">----------------------------------------------------</span>

<span class="cm">LodePNG uses unsigned char arrays for 16-bit per channel colors too, just like</span>
<span class="cm">for any other color format. The 16-bit values are stored in big endian (most</span>
<span class="cm">significant byte first) in these arrays. This is the opposite order of the</span>
<span class="cm">little endian used by x86 CPU&#39;s.</span>

<span class="cm">LodePNG always uses big endian because the PNG file format does so internally.</span>
<span class="cm">Conversions to other formats than PNG uses internally are not supported by</span>
<span class="cm">LodePNG on purpose, there are myriads of formats, including endianness of 16-bit</span>
<span class="cm">colors, the order in which you store R, G, B and A, and so on. Supporting and</span>
<span class="cm">converting to/from all that is outside the scope of LodePNG.</span>

<span class="cm">This may mean that, depending on your use case, you may want to convert the big</span>
<span class="cm">endian output of LodePNG to little endian with a for loop. This is certainly not</span>
<span class="cm">always needed, many applications and libraries support big endian 16-bit colors</span>
<span class="cm">anyway, but it means you cannot simply cast the unsigned char* buffer to an</span>
<span class="cm">unsigned short* buffer on x86 CPUs.</span>


<span class="cm">7. error values</span>
<span class="cm">---------------</span>

<span class="cm">All functions in LodePNG that return an error code, return 0 if everything went</span>
<span class="cm">OK, or a non-zero code if there was an error.</span>

<span class="cm">The meaning of the LodePNG error values can be retrieved with the function</span>
<span class="cm">lodepng_error_text: given the numerical error code, it returns a description</span>
<span class="cm">of the error in English as a string.</span>

<span class="cm">Check the implementation of lodepng_error_text to see the meaning of each code.</span>


<span class="cm">8. chunks and PNG editing</span>
<span class="cm">-------------------------</span>

<span class="cm">If you want to add extra chunks to a PNG you encode, or use LodePNG for a PNG</span>
<span class="cm">editor that should follow the rules about handling of unknown chunks, or if your</span>
<span class="cm">program is able to read other types of chunks than the ones handled by LodePNG,</span>
<span class="cm">then that&#39;s possible with the chunk functions of LodePNG.</span>

<span class="cm">A PNG chunk has the following layout:</span>

<span class="cm">4 bytes length</span>
<span class="cm">4 bytes type name</span>
<span class="cm">length bytes data</span>
<span class="cm">4 bytes CRC</span>

<span class="cm">8.1. iterating through chunks</span>
<span class="cm">-----------------------------</span>

<span class="cm">If you have a buffer containing the PNG image data, then the first chunk (the</span>
<span class="cm">IHDR chunk) starts at byte number 8 of that buffer. The first 8 bytes are the</span>
<span class="cm">signature of the PNG and are not part of a chunk. But if you start at byte 8</span>
<span class="cm">then you have a chunk, and can check the following things of it.</span>

<span class="cm">NOTE: none of these functions check for memory buffer boundaries. To avoid</span>
<span class="cm">exploits, always make sure the buffer contains all the data of the chunks.</span>
<span class="cm">When using lodepng_chunk_next, make sure the returned value is within the</span>
<span class="cm">allocated memory.</span>

<span class="cm">unsigned lodepng_chunk_length(const unsigned char* chunk):</span>

<span class="cm">Get the length of the chunk&#39;s data. The total chunk length is this length + 12.</span>

<span class="cm">void lodepng_chunk_type(char type[5], const unsigned char* chunk):</span>
<span class="cm">unsigned char lodepng_chunk_type_equals(const unsigned char* chunk, const char* type):</span>

<span class="cm">Get the type of the chunk or compare if it&#39;s a certain type</span>

<span class="cm">unsigned char lodepng_chunk_critical(const unsigned char* chunk):</span>
<span class="cm">unsigned char lodepng_chunk_private(const unsigned char* chunk):</span>
<span class="cm">unsigned char lodepng_chunk_safetocopy(const unsigned char* chunk):</span>

<span class="cm">Check if the chunk is critical in the PNG standard (only IHDR, PLTE, IDAT and IEND are).</span>
<span class="cm">Check if the chunk is private (public chunks are part of the standard, private ones not).</span>
<span class="cm">Check if the chunk is safe to copy. If it&#39;s not, then, when modifying data in a critical</span>
<span class="cm">chunk, unsafe to copy chunks of the old image may NOT be saved in the new one if your</span>
<span class="cm">program doesn&#39;t handle that type of unknown chunk.</span>

<span class="cm">unsigned char* lodepng_chunk_data(unsigned char* chunk):</span>
<span class="cm">const unsigned char* lodepng_chunk_data_const(const unsigned char* chunk):</span>

<span class="cm">Get a pointer to the start of the data of the chunk.</span>

<span class="cm">unsigned lodepng_chunk_check_crc(const unsigned char* chunk):</span>
<span class="cm">void lodepng_chunk_generate_crc(unsigned char* chunk):</span>

<span class="cm">Check if the crc is correct or generate a correct one.</span>

<span class="cm">unsigned char* lodepng_chunk_next(unsigned char* chunk):</span>
<span class="cm">const unsigned char* lodepng_chunk_next_const(const unsigned char* chunk):</span>

<span class="cm">Iterate to the next chunk. This works if you have a buffer with consecutive chunks. Note that these</span>
<span class="cm">functions do no boundary checking of the allocated data whatsoever, so make sure there is enough</span>
<span class="cm">data available in the buffer to be able to go to the next chunk.</span>

<span class="cm">unsigned lodepng_chunk_append(unsigned char** out, size_t* outsize, const unsigned char* chunk):</span>
<span class="cm">unsigned lodepng_chunk_create(unsigned char** out, size_t* outsize, unsigned length,</span>
<span class="cm">                              const char* type, const unsigned char* data):</span>

<span class="cm">These functions are used to create new chunks that are appended to the data in *out that has</span>
<span class="cm">length *outsize. The append function appends an existing chunk to the new data. The create</span>
<span class="cm">function creates a new chunk with the given parameters and appends it. Type is the 4-letter</span>
<span class="cm">name of the chunk.</span>

<span class="cm">8.2. chunks in info_png</span>
<span class="cm">-----------------------</span>

<span class="cm">The LodePNGInfo struct contains fields with the unknown chunk in it. It has 3</span>
<span class="cm">buffers (each with size) to contain 3 types of unknown chunks:</span>
<span class="cm">the ones that come before the PLTE chunk, the ones that come between the PLTE</span>
<span class="cm">and the IDAT chunks, and the ones that come after the IDAT chunks.</span>
<span class="cm">It&#39;s necessary to make the distinction between these 3 cases because the PNG</span>
<span class="cm">standard forces to keep the ordering of unknown chunks compared to the critical</span>
<span class="cm">chunks, but does not force any other ordering rules.</span>

<span class="cm">info_png.unknown_chunks_data[0] is the chunks before PLTE</span>
<span class="cm">info_png.unknown_chunks_data[1] is the chunks after PLTE, before IDAT</span>
<span class="cm">info_png.unknown_chunks_data[2] is the chunks after IDAT</span>

<span class="cm">The chunks in these 3 buffers can be iterated through and read by using the same</span>
<span class="cm">way described in the previous subchapter.</span>

<span class="cm">When using the decoder to decode a PNG, you can make it store all unknown chunks</span>
<span class="cm">if you set the option settings.remember_unknown_chunks to 1. By default, this</span>
<span class="cm">option is off (0).</span>

<span class="cm">The encoder will always encode unknown chunks that are stored in the info_png.</span>
<span class="cm">If you need it to add a particular chunk that isn&#39;t known by LodePNG, you can</span>
<span class="cm">use lodepng_chunk_append or lodepng_chunk_create to the chunk data in</span>
<span class="cm">info_png.unknown_chunks_data[x].</span>

<span class="cm">Chunks that are known by LodePNG should not be added in that way. E.g. to make</span>
<span class="cm">LodePNG add a bKGD chunk, set background_defined to true and add the correct</span>
<span class="cm">parameters there instead.</span>


<span class="cm">9. compiler support</span>
<span class="cm">-------------------</span>

<span class="cm">No libraries other than the current standard C library are needed to compile</span>
<span class="cm">LodePNG. For the C++ version, only the standard C++ library is needed on top.</span>
<span class="cm">Add the files lodepng.c(pp) and lodepng.h to your project, include</span>
<span class="cm">lodepng.h where needed, and your program can read/write PNG files.</span>

<span class="cm">It is compatible with C90 and up, and C++03 and up.</span>

<span class="cm">If performance is important, use optimization when compiling! For both the</span>
<span class="cm">encoder and decoder, this makes a large difference.</span>

<span class="cm">Make sure that LodePNG is compiled with the same compiler of the same version</span>
<span class="cm">and with the same settings as the rest of the program, or the interfaces with</span>
<span class="cm">std::vectors and std::strings in C++ can be incompatible.</span>

<span class="cm">CHAR_BITS must be 8 or higher, because LodePNG uses unsigned chars for octets.</span>

<span class="cm">*) gcc and g++</span>

<span class="cm">LodePNG is developed in gcc so this compiler is natively supported. It gives no</span>
<span class="cm">warnings with compiler options &quot;-Wall -Wextra -pedantic -ansi&quot;, with gcc and g++</span>
<span class="cm">version 4.7.1 on Linux, 32-bit and 64-bit.</span>

<span class="cm">*) Clang</span>

<span class="cm">Fully supported and warning-free.</span>

<span class="cm">*) Mingw</span>

<span class="cm">The Mingw compiler (a port of gcc for Windows) should be fully supported by</span>
<span class="cm">LodePNG.</span>

<span class="cm">*) Visual Studio and Visual C++ Express Edition</span>

<span class="cm">LodePNG should be warning-free with warning level W4. Two warnings were disabled</span>
<span class="cm">with pragmas though: warning 4244 about implicit conversions, and warning 4996</span>
<span class="cm">where it wants to use a non-standard function fopen_s instead of the standard C</span>
<span class="cm">fopen.</span>

<span class="cm">Visual Studio may want &quot;stdafx.h&quot; files to be included in each source file and</span>
<span class="cm">give an error &quot;unexpected end of file while looking for precompiled header&quot;.</span>
<span class="cm">This is not standard C++ and will not be added to the stock LodePNG. You can</span>
<span class="cm">disable it for lodepng.cpp only by right clicking it, Properties, C/C++,</span>
<span class="cm">Precompiled Headers, and set it to Not Using Precompiled Headers there.</span>

<span class="cm">NOTE: Modern versions of VS should be fully supported, but old versions, e.g.</span>
<span class="cm">VS6, are not guaranteed to work.</span>

<span class="cm">*) Compilers on Macintosh</span>

<span class="cm">LodePNG has been reported to work both with gcc and LLVM for Macintosh, both for</span>
<span class="cm">C and C++.</span>

<span class="cm">*) Other Compilers</span>

<span class="cm">If you encounter problems on any compilers, feel free to let me know and I may</span>
<span class="cm">try to fix it if the compiler is modern and standards compliant.</span>


<span class="cm">10. examples</span>
<span class="cm">------------</span>

<span class="cm">This decoder example shows the most basic usage of LodePNG. More complex</span>
<span class="cm">examples can be found on the LodePNG website.</span>

<span class="cm">10.1. decoder C++ example</span>
<span class="cm">-------------------------</span>

<span class="cm">#include &quot;lodepng.h&quot;</span>
<span class="cm">#include &lt;iostream&gt;</span>

<span class="cm">int main(int argc, char *argv[]) {</span>
<span class="cm">  const char* filename = argc &gt; 1 ? argv[1] : &quot;test.png&quot;;</span>

<span class="cm">  //load and decode</span>
<span class="cm">  std::vector&lt;unsigned char&gt; image;</span>
<span class="cm">  unsigned width, height;</span>
<span class="cm">  unsigned error = lodepng::decode(image, width, height, filename);</span>

<span class="cm">  //if there&#39;s an error, display it</span>
<span class="cm">  if(error) std::cout &lt;&lt; &quot;decoder error &quot; &lt;&lt; error &lt;&lt; &quot;: &quot; &lt;&lt; lodepng_error_text(error) &lt;&lt; std::endl;</span>

<span class="cm">  //the pixels are now in the vector &quot;image&quot;, 4 bytes per pixel, ordered RGBARGBA..., use it as texture, draw it, ...</span>
<span class="cm">}</span>

<span class="cm">10.2. decoder C example</span>
<span class="cm">-----------------------</span>

<span class="cm">#include &quot;lodepng.h&quot;</span>

<span class="cm">int main(int argc, char *argv[]) {</span>
<span class="cm">  unsigned error;</span>
<span class="cm">  unsigned char* image;</span>
<span class="cm">  size_t width, height;</span>
<span class="cm">  const char* filename = argc &gt; 1 ? argv[1] : &quot;test.png&quot;;</span>

<span class="cm">  error = lodepng_decode32_file(&amp;image, &amp;width, &amp;height, filename);</span>

<span class="cm">  if(error) printf(&quot;decoder error %u: %s\n&quot;, error, lodepng_error_text(error));</span>

<span class="cm">  / * use image here * /</span>

<span class="cm">  free(image);</span>
<span class="cm">  return 0;</span>
<span class="cm">}</span>

<span class="cm">11. state settings reference</span>
<span class="cm">----------------------------</span>

<span class="cm">A quick reference of some settings to set on the LodePNGState</span>

<span class="cm">For decoding:</span>

<span class="cm">state.decoder.zlibsettings.ignore_adler32: ignore ADLER32 checksums</span>
<span class="cm">state.decoder.zlibsettings.custom_...: use custom inflate function</span>
<span class="cm">state.decoder.ignore_crc: ignore CRC checksums</span>
<span class="cm">state.decoder.ignore_critical: ignore unknown critical chunks</span>
<span class="cm">state.decoder.ignore_end: ignore missing IEND chunk. May fail if this corruption causes other errors</span>
<span class="cm">state.decoder.color_convert: convert internal PNG color to chosen one</span>
<span class="cm">state.decoder.read_text_chunks: whether to read in text metadata chunks</span>
<span class="cm">state.decoder.remember_unknown_chunks: whether to read in unknown chunks</span>
<span class="cm">state.info_raw.colortype: desired color type for decoded image</span>
<span class="cm">state.info_raw.bitdepth: desired bit depth for decoded image</span>
<span class="cm">state.info_raw....: more color settings, see struct LodePNGColorMode</span>
<span class="cm">state.info_png....: no settings for decoder but ouput, see struct LodePNGInfo</span>

<span class="cm">For encoding:</span>

<span class="cm">state.encoder.zlibsettings.btype: disable compression by setting it to 0</span>
<span class="cm">state.encoder.zlibsettings.use_lz77: use LZ77 in compression</span>
<span class="cm">state.encoder.zlibsettings.windowsize: tweak LZ77 windowsize</span>
<span class="cm">state.encoder.zlibsettings.minmatch: tweak min LZ77 length to match</span>
<span class="cm">state.encoder.zlibsettings.nicematch: tweak LZ77 match where to stop searching</span>
<span class="cm">state.encoder.zlibsettings.lazymatching: try one more LZ77 matching</span>
<span class="cm">state.encoder.zlibsettings.custom_...: use custom deflate function</span>
<span class="cm">state.encoder.auto_convert: choose optimal PNG color type, if 0 uses info_png</span>
<span class="cm">state.encoder.filter_palette_zero: PNG filter strategy for palette</span>
<span class="cm">state.encoder.filter_strategy: PNG filter strategy to encode with</span>
<span class="cm">state.encoder.force_palette: add palette even if not encoding to one</span>
<span class="cm">state.encoder.add_id: add LodePNG identifier and version as a text chunk</span>
<span class="cm">state.encoder.text_compression: use compressed text chunks for metadata</span>
<span class="cm">state.info_raw.colortype: color type of raw input image you provide</span>
<span class="cm">state.info_raw.bitdepth: bit depth of raw input image you provide</span>
<span class="cm">state.info_raw: more color settings, see struct LodePNGColorMode</span>
<span class="cm">state.info_png.color.colortype: desired color type if auto_convert is false</span>
<span class="cm">state.info_png.color.bitdepth: desired bit depth if auto_convert is false</span>
<span class="cm">state.info_png.color....: more color settings, see struct LodePNGColorMode</span>
<span class="cm">state.info_png....: more PNG related settings, see struct LodePNGInfo</span>


<span class="cm">12. changes</span>
<span class="cm">-----------</span>

<span class="cm">The version number of LodePNG is the date of the change given in the format</span>
<span class="cm">yyyymmdd.</span>

<span class="cm">Some changes aren&#39;t backwards compatible. Those are indicated with a (!)</span>
<span class="cm">symbol.</span>

<span class="cm">Not all changes are listed here, the commit history in github lists more:</span>
<span class="cm">https://github.com/lvandeve/lodepng</span>

<span class="cm">*) 06 mar 2020: simplified some of the dynamic memory allocations.</span>
<span class="cm">*) 12 jan 2020: (!) added &#39;end&#39; argument to lodepng_chunk_next to allow correct</span>
<span class="cm">   overflow checks.</span>
<span class="cm">*) 14 aug 2019: around 25% faster decoding thanks to huffman lookup tables.</span>
<span class="cm">*) 15 jun 2019: (!) auto_choose_color API changed (for bugfix: don&#39;t use palette</span>
<span class="cm">   if gray ICC profile) and non-ICC LodePNGColorProfile renamed to</span>
<span class="cm">   LodePNGColorStats.</span>
<span class="cm">*) 30 dec 2018: code style changes only: removed newlines before opening braces.</span>
<span class="cm">*) 10 sep 2018: added way to inspect metadata chunks without full decoding.</span>
<span class="cm">*) 19 aug 2018: (!) fixed color mode bKGD is encoded with and made it use</span>
<span class="cm">   palette index in case of palette.</span>
<span class="cm">*) 10 aug 2018: (!) added support for gAMA, cHRM, sRGB and iCCP chunks. This</span>
<span class="cm">   change is backwards compatible unless you relied on unknown_chunks for those.</span>
<span class="cm">*) 11 jun 2018: less restrictive check for pixel size integer overflow</span>
<span class="cm">*) 14 jan 2018: allow optionally ignoring a few more recoverable errors</span>
<span class="cm">*) 17 sep 2017: fix memory leak for some encoder input error cases</span>
<span class="cm">*) 27 nov 2016: grey+alpha auto color model detection bugfix</span>
<span class="cm">*) 18 apr 2016: Changed qsort to custom stable sort (for platforms w/o qsort).</span>
<span class="cm">*) 09 apr 2016: Fixed colorkey usage detection, and better file loading (within</span>
<span class="cm">   the limits of pure C90).</span>
<span class="cm">*) 08 dec 2015: Made load_file function return error if file can&#39;t be opened.</span>
<span class="cm">*) 24 okt 2015: Bugfix with decoding to palette output.</span>
<span class="cm">*) 18 apr 2015: Boundary PM instead of just package-merge for faster encoding.</span>
<span class="cm">*) 24 aug 2014: Moved to github</span>
<span class="cm">*) 23 aug 2014: Reduced needless memory usage of decoder.</span>
<span class="cm">*) 28 jun 2014: Removed fix_png setting, always support palette OOB for</span>
<span class="cm">    simplicity. Made ColorProfile public.</span>
<span class="cm">*) 09 jun 2014: Faster encoder by fixing hash bug and more zeros optimization.</span>
<span class="cm">*) 22 dec 2013: Power of two windowsize required for optimization.</span>
<span class="cm">*) 15 apr 2013: Fixed bug with LAC_ALPHA and color key.</span>
<span class="cm">*) 25 mar 2013: Added an optional feature to ignore some PNG errors (fix_png).</span>
<span class="cm">*) 11 mar 2013: (!) Bugfix with custom free. Changed from &quot;my&quot; to &quot;lodepng_&quot;</span>
<span class="cm">    prefix for the custom allocators and made it possible with a new #define to</span>
<span class="cm">    use custom ones in your project without needing to change lodepng&#39;s code.</span>
<span class="cm">*) 28 jan 2013: Bugfix with color key.</span>
<span class="cm">*) 27 okt 2012: Tweaks in text chunk keyword length error handling.</span>
<span class="cm">*) 8 okt 2012: (!) Added new filter strategy (entropy) and new auto color mode.</span>
<span class="cm">    (no palette). Better deflate tree encoding. New compression tweak settings.</span>
<span class="cm">    Faster color conversions while decoding. Some internal cleanups.</span>
<span class="cm">*) 23 sep 2012: Reduced warnings in Visual Studio a little bit.</span>
<span class="cm">*) 1 sep 2012: (!) Removed #define&#39;s for giving custom (de)compression functions</span>
<span class="cm">    and made it work with function pointers instead.</span>
<span class="cm">*) 23 jun 2012: Added more filter strategies. Made it easier to use custom alloc</span>
<span class="cm">    and free functions and toggle #defines from compiler flags. Small fixes.</span>
<span class="cm">*) 6 may 2012: (!) Made plugging in custom zlib/deflate functions more flexible.</span>
<span class="cm">*) 22 apr 2012: (!) Made interface more consistent, renaming a lot. Removed</span>
<span class="cm">    redundant C++ codec classes. Reduced amount of structs. Everything changed,</span>
<span class="cm">    but it is cleaner now imho and functionality remains the same. Also fixed</span>
<span class="cm">    several bugs and shrunk the implementation code. Made new samples.</span>
<span class="cm">*) 6 nov 2011: (!) By default, the encoder now automatically chooses the best</span>
<span class="cm">    PNG color model and bit depth, based on the amount and type of colors of the</span>
<span class="cm">    raw image. For this, autoLeaveOutAlphaChannel replaced by auto_choose_color.</span>
<span class="cm">*) 9 okt 2011: simpler hash chain implementation for the encoder.</span>
<span class="cm">*) 8 sep 2011: lz77 encoder lazy matching instead of greedy matching.</span>
<span class="cm">*) 23 aug 2011: tweaked the zlib compression parameters after benchmarking.</span>
<span class="cm">    A bug with the PNG filtertype heuristic was fixed, so that it chooses much</span>
<span class="cm">    better ones (it&#39;s quite significant). A setting to do an experimental, slow,</span>
<span class="cm">    brute force search for PNG filter types is added.</span>
<span class="cm">*) 17 aug 2011: (!) changed some C zlib related function names.</span>
<span class="cm">*) 16 aug 2011: made the code less wide (max 120 characters per line).</span>
<span class="cm">*) 17 apr 2011: code cleanup. Bugfixes. Convert low to 16-bit per sample colors.</span>
<span class="cm">*) 21 feb 2011: fixed compiling for C90. Fixed compiling with sections disabled.</span>
<span class="cm">*) 11 dec 2010: encoding is made faster, based on suggestion by Peter Eastman</span>
<span class="cm">    to optimize long sequences of zeros.</span>
<span class="cm">*) 13 nov 2010: added LodePNG_InfoColor_hasPaletteAlpha and</span>
<span class="cm">    LodePNG_InfoColor_canHaveAlpha functions for convenience.</span>
<span class="cm">*) 7 nov 2010: added LodePNG_error_text function to get error code description.</span>
<span class="cm">*) 30 okt 2010: made decoding slightly faster</span>
<span class="cm">*) 26 okt 2010: (!) changed some C function and struct names (more consistent).</span>
<span class="cm">     Reorganized the documentation and the declaration order in the header.</span>
<span class="cm">*) 08 aug 2010: only changed some comments and external samples.</span>
<span class="cm">*) 05 jul 2010: fixed bug thanks to warnings in the new gcc version.</span>
<span class="cm">*) 14 mar 2010: fixed bug where too much memory was allocated for char buffers.</span>
<span class="cm">*) 02 sep 2008: fixed bug where it could create empty tree that linux apps could</span>
<span class="cm">    read by ignoring the problem but windows apps couldn&#39;t.</span>
<span class="cm">*) 06 jun 2008: added more error checks for out of memory cases.</span>
<span class="cm">*) 26 apr 2008: added a few more checks here and there to ensure more safety.</span>
<span class="cm">*) 06 mar 2008: crash with encoding of strings fixed</span>
<span class="cm">*) 02 feb 2008: support for international text chunks added (iTXt)</span>
<span class="cm">*) 23 jan 2008: small cleanups, and #defines to divide code in sections</span>
<span class="cm">*) 20 jan 2008: support for unknown chunks allowing using LodePNG for an editor.</span>
<span class="cm">*) 18 jan 2008: support for tIME and pHYs chunks added to encoder and decoder.</span>
<span class="cm">*) 17 jan 2008: ability to encode and decode compressed zTXt chunks added</span>
<span class="cm">    Also various fixes, such as in the deflate and the padding bits code.</span>
<span class="cm">*) 13 jan 2008: Added ability to encode Adam7-interlaced images. Improved</span>
<span class="cm">    filtering code of encoder.</span>
<span class="cm">*) 07 jan 2008: (!) changed LodePNG to use ISO C90 instead of C++. A</span>
<span class="cm">    C++ wrapper around this provides an interface almost identical to before.</span>
<span class="cm">    Having LodePNG be pure ISO C90 makes it more portable. The C and C++ code</span>
<span class="cm">    are together in these files but it works both for C and C++ compilers.</span>
<span class="cm">*) 29 dec 2007: (!) changed most integer types to unsigned int + other tweaks</span>
<span class="cm">*) 30 aug 2007: bug fixed which makes this Borland C++ compatible</span>
<span class="cm">*) 09 aug 2007: some VS2005 warnings removed again</span>
<span class="cm">*) 21 jul 2007: deflate code placed in new namespace separate from zlib code</span>
<span class="cm">*) 08 jun 2007: fixed bug with 2- and 4-bit color, and small interlaced images</span>
<span class="cm">*) 04 jun 2007: improved support for Visual Studio 2005: crash with accessing</span>
<span class="cm">    invalid std::vector element [0] fixed, and level 3 and 4 warnings removed</span>
<span class="cm">*) 02 jun 2007: made the encoder add a tag with version by default</span>
<span class="cm">*) 27 may 2007: zlib and png code separated (but still in the same file),</span>
<span class="cm">    simple encoder/decoder functions added for more simple usage cases</span>
<span class="cm">*) 19 may 2007: minor fixes, some code cleaning, new error added (error 69),</span>
<span class="cm">    moved some examples from here to lodepng_examples.cpp</span>
<span class="cm">*) 12 may 2007: palette decoding bug fixed</span>
<span class="cm">*) 24 apr 2007: changed the license from BSD to the zlib license</span>
<span class="cm">*) 11 mar 2007: very simple addition: ability to encode bKGD chunks.</span>
<span class="cm">*) 04 mar 2007: (!) tEXt chunk related fixes, and support for encoding</span>
<span class="cm">    palettized PNG images. Plus little interface change with palette and texts.</span>
<span class="cm">*) 03 mar 2007: Made it encode dynamic Huffman shorter with repeat codes.</span>
<span class="cm">    Fixed a bug where the end code of a block had length 0 in the Huffman tree.</span>
<span class="cm">*) 26 feb 2007: Huffman compression with dynamic trees (BTYPE 2) now implemented</span>
<span class="cm">    and supported by the encoder, resulting in smaller PNGs at the output.</span>
<span class="cm">*) 27 jan 2007: Made the Adler-32 test faster so that a timewaste is gone.</span>
<span class="cm">*) 24 jan 2007: gave encoder an error interface. Added color conversion from any</span>
<span class="cm">    greyscale type to 8-bit greyscale with or without alpha.</span>
<span class="cm">*) 21 jan 2007: (!) Totally changed the interface. It allows more color types</span>
<span class="cm">    to convert to and is more uniform. See the manual for how it works now.</span>
<span class="cm">*) 07 jan 2007: Some cleanup &amp; fixes, and a few changes over the last days:</span>
<span class="cm">    encode/decode custom tEXt chunks, separate classes for zlib &amp; deflate, and</span>
<span class="cm">    at last made the decoder give errors for incorrect Adler32 or Crc.</span>
<span class="cm">*) 01 jan 2007: Fixed bug with encoding PNGs with less than 8 bits per channel.</span>
<span class="cm">*) 29 dec 2006: Added support for encoding images without alpha channel, and</span>
<span class="cm">    cleaned out code as well as making certain parts faster.</span>
<span class="cm">*) 28 dec 2006: Added &quot;Settings&quot; to the encoder.</span>
<span class="cm">*) 26 dec 2006: The encoder now does LZ77 encoding and produces much smaller files now.</span>
<span class="cm">    Removed some code duplication in the decoder. Fixed little bug in an example.</span>
<span class="cm">*) 09 dec 2006: (!) Placed output parameters of public functions as first parameter.</span>
<span class="cm">    Fixed a bug of the decoder with 16-bit per color.</span>
<span class="cm">*) 15 okt 2006: Changed documentation structure</span>
<span class="cm">*) 09 okt 2006: Encoder class added. It encodes a valid PNG image from the</span>
<span class="cm">    given image buffer, however for now it&#39;s not compressed.</span>
<span class="cm">*) 08 sep 2006: (!) Changed to interface with a Decoder class</span>
<span class="cm">*) 30 jul 2006: (!) LodePNG_InfoPng , width and height are now retrieved in different</span>
<span class="cm">    way. Renamed decodePNG to decodePNGGeneric.</span>
<span class="cm">*) 29 jul 2006: (!) Changed the interface: image info is now returned as a</span>
<span class="cm">    struct of type LodePNG::LodePNG_Info, instead of a vector, which was a bit clumsy.</span>
<span class="cm">*) 28 jul 2006: Cleaned the code and added new error checks.</span>
<span class="cm">    Corrected terminology &quot;deflate&quot; into &quot;inflate&quot;.</span>
<span class="cm">*) 23 jun 2006: Added SDL example in the documentation in the header, this</span>
<span class="cm">    example allows easy debugging by displaying the PNG and its transparency.</span>
<span class="cm">*) 22 jun 2006: (!) Changed way to obtain error value. Added</span>
<span class="cm">    loadFile function for convenience. Made decodePNG32 faster.</span>
<span class="cm">*) 21 jun 2006: (!) Changed type of info vector to unsigned.</span>
<span class="cm">    Changed position of palette in info vector. Fixed an important bug that</span>
<span class="cm">    happened on PNGs with an uncompressed block.</span>
<span class="cm">*) 16 jun 2006: Internally changed unsigned into unsigned where</span>
<span class="cm">    needed, and performed some optimizations.</span>
<span class="cm">*) 07 jun 2006: (!) Renamed functions to decodePNG and placed them</span>
<span class="cm">    in LodePNG namespace. Changed the order of the parameters. Rewrote the</span>
<span class="cm">    documentation in the header. Renamed files to lodepng.cpp and lodepng.h</span>
<span class="cm">*) 22 apr 2006: Optimized and improved some code</span>
<span class="cm">*) 07 sep 2005: (!) Changed to std::vector interface</span>
<span class="cm">*) 12 aug 2005: Initial release (C++, decoder only)</span>


<span class="cm">13. contact information</span>
<span class="cm">-----------------------</span>

<span class="cm">Feel free to contact me with suggestions, problems, comments, ... concerning</span>
<span class="cm">LodePNG. If you encounter a PNG image that doesn&#39;t work properly with this</span>
<span class="cm">decoder, feel free to send it and I&#39;ll use it to find and fix the problem.</span>

<span class="cm">My email address is (puzzle the account and domain together with an @ symbol):</span>
<span class="cm">Domain: gmail dot com.</span>
<span class="cm">Account: lode dot vandevenne.</span>


<span class="cm">Copyright (c) 2005-2020 Lode Vandevenne</span>
<span class="cm">*/</span><span class="w"></span>
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Kapareliotis Elias, Papantonis Christos.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>